<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CritterCatcherAI</title>
    
    <!-- Favicons -->
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/static/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/static/android-chrome-512x512.png">
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f7fa;
            --bg-card: #ffffff;
            --text-primary: #2d3748;
            --text-secondary: #718096;
            --border-color: #e2e8f0;
            --accent-color: #4299e1;
            --accent-hover: #3182ce;
            --success-color: #48bb78;
            --warning-color: #ed8936;
            --danger-color: #f56565;
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        [data-theme="dark"] {
            --bg-primary: #1a202c;
            --bg-secondary: #2d3748;
            --bg-card: #2d3748;
            --text-primary: #f7fafc;
            --text-secondary: #a0aec0;
            --border-color: #4a5568;
            --accent-color: #63b3ed;
            --accent-hover: #4299e1;
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 2px 0 rgba(0, 0, 0, 0.25);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.35);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 0;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .logo img {
            width: 48px;
            height: 48px;
            border-radius: 8px;
        }
        
        .logo-text {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .logo-title {
            color: var(--accent-color);
            font-size: 1.25rem;
            font-weight: bold;
            line-height: 1;
        }
        
        .logo-subtitle {
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: normal;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .download-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .form-select {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-card);
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
        }
        
        .btn-warning {
            background: var(--warning-color);
        }
        
        .btn-warning:hover {
            background: #dd6b20;
        }

        .theme-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: var(--accent-color);
            border-color: var(--accent-color);
        }

        .btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-success:hover {
            background: #38a169;
        }

        /* Grid Layout */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
        }

        .card:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .stat-card {
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--accent-color);
            margin: 0.5rem 0;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin: 2rem 0 1rem 0;
            border-bottom: 2px solid var(--border-color);
            overflow-x: auto;
        }

        .tab {
            background: transparent;
            border: none;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            font-weight: 600;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Video Gallery */
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .video-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .video-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
        }

        .video-thumbnail {
            width: 100%;
            height: 150px;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
        }

        .video-info {
            padding: 1rem;
        }

        .video-category {
            display: inline-block;
            background: var(--accent-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .video-title {
            font-size: 0.875rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .video-date {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        /* Logs Viewer */
        .log-viewer {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            line-height: 1.4;
        }

        .log-line {
            padding: 0.25rem 0;
            color: var(--text-primary);
        }

        .log-line.error {
            color: var(--danger-color);
        }

        .log-line.warning {
            color: var(--warning-color);
        }

        .log-line.info {
            color: var(--success-color);
        }

        /* Forms */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        /* Status Badge */
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .status-badge.processing {
            background: rgba(237, 137, 54, 0.1);
            color: var(--warning-color);
        }

        .status-badge.idle {
            background: rgba(72, 187, 120, 0.1);
            color: var(--success-color);
        }

        .status-badge::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            margin-right: 0.5rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Face Training */
        .face-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .face-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        .face-name {
            font-weight: 500;
            font-size: 1rem;
        }

        .face-count {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: var(--accent-color);
            background: rgba(66, 153, 225, 0.05);
        }

        .upload-area.dragover {
            border-color: var(--accent-color);
            background: rgba(66, 153, 225, 0.1);
        }

        /* Loading Spinner */
        .spinner {
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header-content {
                flex-direction: column;
                gap: 1rem;
            }

            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .video-grid {
                grid-template-columns: 1fr;
            }

            .tabs {
                font-size: 0.875rem;
            }

            .tab {
                padding: 0.5rem 1rem;
            }

            .stat-value {
                font-size: 2rem;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-color);
        }
        
        /* Version display */
        .version {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-left: 0.5rem;
        }
        
        .version a {
            color: var(--text-secondary);
            text-decoration: none;
        }
        
        .version a:hover {
            text-decoration: underline;
            color: var(--accent-color);
        }
        
        .build-date {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.2rem;
        }
        
        /* Update notification banner */
        .update-banner {
            background: #ff9800;
            color: #fff;
            padding: 0.8em 1em;
            text-align: center;
            font-weight: 600;
            display: none;
            border-bottom: 3px solid #f57c00;
        }
        
        .update-banner.show {
            display: block;
        }
        
        .update-banner a {
            color: #fff;
            text-decoration: underline;
            font-weight: bold;
        }
        
        .update-banner a:hover {
            color: #ffeb3b;
        }
        
        /* Discovery Mode Tab Styles */
        .tab.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .image-item {
            position: relative;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .image-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .image-item.selected {
            border-color: var(--accent-color);
            border-width: 3px;
        }
        
        .image-item img {
            width: 100%;
            height: 150px;
            object-fit: contain;
            display: block;
            background: var(--bg-secondary);
        }
        
        .image-overlay {
            position: absolute;
            top: 0;
            right: 0;
            background: var(--accent-color);
            color: white;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            border-bottom-left-radius: 4px;
        }
        
        .confidence-badge {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.25rem;
            font-size: 0.75rem;
            text-align: center;
        }
        
        .label-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        
        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .btn-small {
            padding: 0.4rem 1rem;
            font-size: 0.875rem;
        }
        
        /* Image zoom modal */
        .zoom-modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.2s ease;
        }
        
        .zoom-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-modal-content {
            position: relative;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 2rem;
        }
        
        .zoom-modal img {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }
        
        .zoom-modal-info {
            margin-top: 1rem;
            padding: 1rem 2rem;
            background: var(--bg-card);
            border-radius: 8px;
            text-align: center;
            color: var(--text-primary);
        }
        
        .zoom-modal-actions {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        .zoom-modal-close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 3rem;
            font-weight: bold;
            color: white;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            transition: all 0.3s ease;
        }
        
        .zoom-modal-close:hover {
            background: var(--danger-color);
            transform: rotate(90deg);
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 400px;
        }
        
        .toast {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem 1.5rem;
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideIn 0.3s ease;
            min-width: 300px;
        }
        
        .toast.success {
            border-left: 4px solid var(--success-color);
        }
        
        .toast.error {
            border-left: 4px solid var(--danger-color);
        }
        
        .toast.warning {
            border-left: 4px solid var(--warning-color);
        }
        
        .toast-close {
            margin-left: auto;
            cursor: pointer;
            font-size: 1.25rem;
            color: var(--text-secondary);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Filter Controls */
        .filter-controls {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            align-items: center;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .filter-controls label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-right: 0.25rem;
        }
        
        .filter-controls input[type="text"],
        .filter-controls input[type="number"],
        .filter-controls select {
            padding: 0.4rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-card);
            color: var(--text-primary);
            font-size: 0.875rem;
        }
        
        /* Progress Indicator */
        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .progress-content {
            background: var(--bg-card);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            min-width: 300px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: var(--accent-color);
            transition: width 0.3s ease;
        }
        
        /* Lazy Load Placeholder */
        .image-item img[data-src] {
            opacity: 0.3;
            background: var(--bg-secondary);
        }
        
        .image-item img.loaded {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        /* Multi-select dropdown styles */
        .multi-select-container {
            position: relative;
        }

        .multi-select-display {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            min-height: 46px;
        }

        .multi-select-display:hover {
            border-color: var(--accent-color);
        }

        .multi-select-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-top: 4px;
            box-shadow: var(--shadow-lg);
            z-index: 100;
        }

        .multi-select-dropdown.active {
            display: block;
        }

        .multi-select-search {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-primary);
            outline: none;
        }

        .multi-select-option {
            padding: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .multi-select-option:hover {
            background: var(--bg-secondary);
        }

        .multi-select-option input[type="checkbox"] {
            cursor: pointer;
        }

        .selected-tag {
            background: var(--accent-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .selected-tag .remove {
            cursor: pointer;
            font-weight: bold;
        }

        .placeholder-text {
            color: var(--text-secondary);
        }
        
        /* Scheduler Badge */
        .scheduler-badge {
            background: rgba(66, 153, 225, 0.1);
            border: 1px solid var(--accent-color);
            border-radius: 20px;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            color: var(--accent-color);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .scheduler-badge.disabled {
            background: rgba(160, 174, 192, 0.1);
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div id="update-banner" class="update-banner">
        üéâ Update Available! <span id="update-version"></span> - 
        <a id="update-link" href="#" target="_blank">Download Now</a>
    </div>
    <header>
        <div class="header-content">
            <div class="logo">
                <img src="/static/android-chrome-192x192.png" alt="CritterCatcherAI Logo">
                <div class="logo-text">
                    <div class="logo-title">CritterCatcherAI</div>
                    <div class="logo-subtitle">
                        Written by Ahazi | 
                        <span class="version">
                            <a href="https://github.com/Ahazii/CritterCatcherAI/releases/tag/v0.1.0" target="_blank" title="View release">v0.1.0</a>
                        </span>
                         | Built: {{build_date}}
                    </div>
                </div>
            </div>
            <div class="header-actions">
                <div id="schedulerBadge" class="scheduler-badge" style="display: none;" title="Next scheduled run">
                    ‚è∞ <span id="schedulerCountdown">--:--:--</span>
                </div>
                <button class="theme-toggle" onclick="toggleTheme()" id="themeToggle">üåô</button>
                <select id="refreshRate" class="form-select" onchange="updateRefreshRate()" title="Status refresh rate">
                    <option value="2000">Refresh: 2s</option>
                    <option value="5000" selected>Refresh: 5s</option>
                    <option value="10000">Refresh: 10s</option>
                </select>
                <div class="download-controls">
                    <select id="timeRange" class="form-select">
                        <option value="1hour">Last Hour</option>
                        <option value="6hours">Last 6 Hours</option>
                        <option value="24hours" selected>Last 24 Hours</option>
                        <option value="7days">Last 7 Days</option>
                        <option value="30days">Last 30 Days</option>
                        <option value="all">All Available</option>
                    </select>
                    <button class="btn btn-warning" onclick="downloadAllVideos()">‚¨á Download All</button>
                </div>
                <button class="btn btn-success" onclick="triggerProcessing()" id="processNowBtn">‚ñ∂ Process Now</button>
                <button class="btn btn-danger" onclick="stopProcessing()" id="stopProcessingBtn" style="display: none;">‚èπ Stop</button>
            </div>
        </div>
    </header>

    <div class="container">
        <!-- Alert Banner -->
        <div id="alertBanner" style="display: none; background: var(--warning-color); color: white; padding: 1rem; border-radius: 8px; margin: 1rem 0; text-align: center;">
            <strong>‚ö† Ring Not Authenticated</strong> - Please complete Ring authentication in the <a href="#" onclick="switchTab('ring'); return false;" style="color: white; text-decoration: underline; font-weight: bold;">Ring Setup tab</a> to begin processing videos.
        </div>
        
        <!-- Status Section -->
        <div class="dashboard-grid">
            <div class="card stat-card">
                <div class="stat-label">Status</div>
                <div id="statusBadge" class="status-badge idle">Idle</div>
            </div>
            <div class="card stat-card">
                <div class="stat-label">Total Videos
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem; font-weight: normal;">Sorted videos across all categories</div>
                </div>
                <div class="stat-value" id="totalVideos">0</div>
            </div>
            <div class="card stat-card">
                <div class="stat-label">Categories</div>
                <div class="stat-value" id="totalCategories">0</div>
            </div>
            <div class="card stat-card">
                <div class="stat-label">Last Run</div>
                <div class="stat-value" style="font-size: 1rem;" id="lastRun">Never</div>
            </div>
        </div>
        
        <!-- Reprocess & Cleanup Buttons -->
        <div style="margin-top: 1rem; text-align: center; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
            <div style="flex: 0 1 auto;">
                <button class="btn" onclick="cleanupDownloads()" style="background: var(--accent-color); padding: 0.75rem 2rem;">
                    üßπ Cleanup Downloads
                </button>
                <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem; max-width: 300px;">
                    Process ALL videos in downloads folder (ignores age)
                </p>
            </div>
            <div style="flex: 0 1 auto;">
                <button class="btn" onclick="returnVideosToDownloads()" style="background: var(--warning-color); padding: 0.75rem 2rem;">
                    ‚Ü©Ô∏è Return Vids to Downloads
                </button>
                <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem; max-width: 300px;">
                    Move all sorted videos back to downloads folder (does not auto-process)
                </p>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('dashboard')">üìä Dashboard</button>
            <button class="tab" onclick="switchTab('analytics')">üìà Analytics</button>
            <button class="tab" onclick="switchTab('metrics')">üìä Metrics</button>
            <button class="tab" onclick="switchTab('storage')">üíæ Storage</button>
            <button class="tab" onclick="switchTab('videos')">üé• Videos</button>
            <button class="tab" id="discoveryTab" onclick="switchTab('review')">üîç Discovery Mode</button>
            <button class="tab" onclick="window.location.href='/species.html'">ü¶î Species Training</button>
            <button class="tab" onclick="switchTab('ring')">üîî Ring Setup</button>
            <button class="tab" onclick="switchTab('faces')">üë§ Face Training</button>
            <button class="tab" onclick="switchTab('config')">‚öôÔ∏è Configuration</button>
            <button class="tab" onclick="switchTab('logs')">üìã Logs</button>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard" class="tab-content active">
            <div id="dashboardProgress"></div>
            <div class="card">
                <div class="card-title">Video Statistics by Category</div>
                <div id="statsChart"></div>
            </div>
        </div>

        <!-- Analytics Tab -->
        <div id="analytics" class="tab-content">
            <div class="dashboard-grid">
                <div class="card stat-card">
                    <div class="stat-label">Total Videos</div>
                    <div class="stat-value" id="analyticsVideos">0</div>
                </div>
                <div class="card stat-card">
                    <div class="stat-label">Total Detections</div>
                    <div class="stat-value" id="analyticsDetections">0</div>
                </div>
                <div class="card stat-card">
                    <div class="stat-label">Stage 2 Classifications</div>
                    <div class="stat-value" id="analyticsStage2">0</div>
                </div>
                <div class="card stat-card">
                    <div class="stat-label">Trained Faces</div>
                    <div class="stat-value" id="analyticsTrainedFaces">0</div>
                </div>
            </div>
            
            <div class="card" style="margin-top: 1.5rem;">
                <div class="card-title">Specialized Detection Statistics</div>
                <div id="stage2Stats" style="padding: 1rem;">
                    <p style="color: var(--text-secondary);">Loading...</p>
                </div>
            </div>
            
            <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
                <button class="btn" onclick="exportData('detections', 'json')" style="background: var(--success-color);">üì• Export Detections (JSON)</button>
                <button class="btn" onclick="exportData('detections', 'csv')" style="background: var(--success-color);">üì• Export Detections (CSV)</button>
                <button class="btn" onclick="exportData('analytics', 'json')" style="background: var(--accent-color);">üì• Export Analytics (JSON)</button>
                <button class="btn" onclick="exportData('analytics', 'csv')" style="background: var(--accent-color);">üì• Export Analytics (CSV)</button>
            </div>
            
            <div class="card" style="margin-top: 1.5rem;">
                <div class="card-title">Detection Statistics</div>
                <canvas id="analyticsChart" style="max-height: 400px;"></canvas>
            </div>
            
            <div class="card" style="margin-top: 1.5rem;">
                <div class="card-title">Timeline (Last 30 Days)</div>
                <canvas id="timelineChart" style="max-height: 300px;"></canvas>
            </div>
            
            <div class="card" style="margin-top: 1.5rem;">
                <div class="card-title">Top 10 Detections</div>
                <div id="topDetections"></div>
            </div>
            
            <div class="card" style="margin-top: 1.5rem;">
                <div class="card-title">Face Recognition Statistics</div>
                <div id="faceRecognitionStats"></div>
            </div>
        </div>

        <!-- Metrics Tab -->
        <div id="metrics" class="tab-content">
            <div class="dashboard-grid">
                <div class="card stat-card">
                    <div class="stat-label">CPU Usage</div>
                    <div class="stat-value" id="metricsCPU">0%</div>
                </div>
                <div class="card stat-card">
                    <div class="stat-label">Memory Usage</div>
                    <div class="stat-value" id="metricsMemory">0%</div>
                </div>
                <div class="card stat-card">
                    <div class="stat-label">Disk Usage</div>
                    <div class="stat-value" id="metricsDisk">0%</div>
                </div>
                <div class="card stat-card">
                    <div class="stat-label">Processing Status</div>
                    <div class="stat-value" style="font-size: 1rem;" id="metricsProcessing">Idle</div>
                </div>
            </div>
            
            <div class="card" style="margin-top: 1.5rem;">
                <div class="card-title">Storage Breakdown</div>
                <canvas id="storageChart" style="max-height: 300px;"></canvas>
            </div>
            
            <div class="card" style="margin-top: 1.5rem;">
                <div class="card-title">System Metrics</div>
                <div id="systemMetricsDetails"></div>
            </div>
            
            <div style="text-align: center; margin-top: 1rem;">
                <button class="btn" onclick="loadMetrics()" style="padding: 0.75rem 2rem;">üîÑ Refresh Metrics</button>
            </div>
        </div>

        <!-- Storage Management Tab -->
        <div id="storage" class="tab-content">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <div class="card-title" style="margin-bottom: 0;">üíæ Sorted Video Storage</div>
                    <button class="btn" onclick="loadStorageData()" style="padding: 0.4rem 1rem; font-size: 0.875rem;">üîÑ Refresh</button>
                </div>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Manage sorted videos by category. Each category shows the video count and total size. Deleting a category removes all videos and their metadata.
                </p>
                <div id="storageList" style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <div style="text-align: center; padding: 2rem;">
                        <div class="spinner"></div>
                        <p style="margin-top: 1rem;">Loading storage data...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Videos Tab -->
        <div id="videos" class="tab-content">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <div class="card-title" style="margin-bottom: 0;">Recent Videos</div>
                    <button class="btn" onclick="loadVideos()" style="padding: 0.4rem 1rem; font-size: 0.875rem;">üîÑ Refresh</button>
                </div>
                <div class="video-grid" id="videoGrid"></div>
            </div>
        </div>
        
        <!-- Review & Label Tab -->
        <div id="review" class="tab-content">
            <!-- Discoveries Section -->
            <div class="card" style="background: rgba(66, 153, 225, 0.05);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <div class="card-title" style="margin-bottom: 0;">üîç Discovered Objects <span id="discoveryBadge" class="status-badge" style="margin-left: 0.5rem; display: none;"></span></div>
                    <button class="btn btn-small" onclick="loadDiscoveries()">üîÑ Refresh</button>
                </div>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Discovery Mode found these objects in your videos. Choose what to do with each:
                    <br><strong>‚úì Enable</strong> = Add to Species Training page and start tracking
                    <br><strong>‚úó Blacklist</strong> = Stop suggesting this (AI is correct, but you don't care)
                    <br><strong>‚ùå Wrong Label</strong> = AI misidentified this object
                </p>
                <div class="filter-controls" id="discoveryFilters" style="display: none;">
                    <label>Search: <input type="text" id="discoverySearchInput" placeholder="Filter by label..." oninput="filterDiscoveries()" /></label>
                    <label>Min Confidence: <input type="number" id="discoveryMinConfidence" min="0" max="1" step="0.1" value="0" oninput="filterDiscoveries()" /></label>
                    <label>Sort: <select id="discoverySortBy" onchange="filterDiscoveries()">
                        <option value="label">Label</option>
                        <option value="confidence">Confidence</option>
                        <option value="date">First Seen</option>
                    </select></label>
                    <button class="btn btn-small" onclick="resetDiscoveryFilters()" style="margin-left: auto;">üîÑ Reset</button>
                </div>
                <div id="discoveriesContainer"></div>
            </div>
            
            <!-- Unknown Faces Section -->
            <div class="card" style="margin-top: 1.5rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <div class="card-title" style="margin-bottom: 0;">Unknown Faces</div>
                    <button class="btn btn-small" onclick="loadUnknownFaces()">üîÑ Refresh</button>
                </div>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Click faces to select them, then enter a name and click "Label Selected" to train the AI.
                </p>
                <div id="unknownFacesContainer"></div>
            </div>
            
            <!-- Detected Objects Section -->
            <div class="card" style="margin-top: 1.5rem; background: rgba(72, 187, 120, 0.05);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <div class="card-title" style="margin-bottom: 0;">Detected Objects</div>
                    <button class="btn btn-small" onclick="loadDetectedObjects()">üîÑ Refresh</button>
                </div>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Review AI detections and correct any misclassifications or add new object types.
                    <br><em style="font-size: 0.875rem;">Tip: Ctrl+Click to select multiple, Shift+Click for range, Ctrl+A to select all</em>
                </p>
                <div class="filter-controls" id="detectedFilters" style="display: none;">
                    <label>Search: <input type="text" id="detectedSearchInput" placeholder="Filter by label..." oninput="filterDetectedObjects()" /></label>
                    <label>Min Confidence: <input type="number" id="detectedMinConfidence" min="0" max="1" step="0.1" value="0" oninput="filterDetectedObjects()" /></label>
                    <label>Sort: <select id="detectedSortBy" onchange="filterDetectedObjects()">
                        <option value="label">Label</option>
                        <option value="confidence">Confidence</option>
                    </select></label>
                    <button class="btn btn-small" onclick="resetDetectedFilters()" style="margin-left: auto;">üîÑ Reset</button>
                </div>
                <div id="detectedObjectsContainer"></div>
            </div>
        </div>

        <!-- Ring Setup Tab -->
        <div id="ring" class="tab-content">
            <div class="card">
                <div class="card-title">Ring Authentication Status</div>
                <div id="ringStatus" style="padding: 1rem; text-align: center;">
                    <div class="spinner"></div>
                    <p>Checking authentication status...</p>
                </div>
            </div>
            <div class="card" style="margin-top: 1.5rem;" id="ringAuthCard">
                <div class="card-title">Setup Ring Authentication</div>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Enter your Ring credentials. If you have 2FA enabled, you'll be prompted for the code.
                </p>
                <div class="form-group">
                    <label class="form-label">Ring Email Address</label>
                    <input type="email" class="form-input" id="ringUsername" placeholder="your@email.com">
                </div>
                <div class="form-group">
                    <label class="form-label">Ring Password</label>
                    <input type="password" class="form-input" id="ringPassword" placeholder="Enter your password">
                </div>
                <div class="form-group" id="ring2faGroup" style="display: none;">
                    <label class="form-label">2FA Code</label>
                    <input type="text" class="form-input" id="ring2faCode" placeholder="Enter 6-digit code" maxlength="6">
                    <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                        Check your email, SMS, or authenticator app for the code.
                    </p>
                </div>
                <button class="btn" onclick="authenticateRing()" id="ringAuthBtn">Authenticate with Ring</button>
                <div id="ringAuthMessage" style="margin-top: 1rem;"></div>
            </div>
        </div>

        <!-- Face Training Tab -->
        <div id="faces" class="tab-content">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <div class="card-title" style="margin-bottom: 0;">Trained People</div>
                    <button class="btn" onclick="retrainAllFaces()" style="background: var(--accent-color); padding: 0.5rem 1rem;">üîÑ Retrain All</button>
                </div>
                <div class="face-list" id="faceList"></div>
            </div>
            <div class="card" style="margin-top: 1.5rem;">
                <div class="card-title">Add Training Photos</div>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Upload clear photos of a person's face for training. Upload 3-5 photos for best results.
                </p>
                <div class="form-group">
                    <label class="form-label">Person Name</label>
                    <input type="text" class="form-input" id="personName" placeholder="Enter person's name">
                </div>
                <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                    <div style="font-size: 3rem; margin-bottom: 1rem;">üì§</div>
                    <div>Click or drag files here to upload</div>
                    <div style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">JPG or PNG images (3-5 photos recommended)</div>
                </div>
                <input type="file" id="fileInput" accept="image/jpeg,image/png" multiple style="display: none;" onchange="uploadFiles()">
            </div>
        </div>

        <!-- Configuration Tab -->
        <div id="config" class="tab-content">
            <div class="card">
                <div class="card-title">Configuration</div>
                <div id="configForm"></div>
            </div>
        </div>

        <!-- Logs Tab -->
        <div id="logs" class="tab-content">
            <div class="card">
                <div class="card-title">Real-time Logs</div>
                <div class="log-viewer" id="logViewer"></div>
            </div>
        </div>
    </div>
    
    <!-- Image Zoom Modal -->
    <div id="zoomModal" class="zoom-modal" onclick="closeZoomModal(event)">
        <span class="zoom-modal-close" onclick="closeZoomModal(event)">&times;</span>
        <div class="zoom-modal-content" onclick="event.stopPropagation()">
            <img id="zoomModalImage" src="" alt="Zoomed view">
            <div id="zoomModalInfo" class="zoom-modal-info"></div>
            <div id="zoomModalActions" class="zoom-modal-actions" style="display: none;">
                <button class="btn btn-success" onclick="confirmFromZoom(event)" style="padding: 0.75rem 1.5rem;">‚úì Confirm</button>
                <button class="btn" onclick="deleteFromZoom(event)" style="background: var(--danger-color); padding: 0.75rem 1.5rem;">‚úó Delete</button>
            </div>
        </div>
    </div>
    
    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>

    <script>
        // Global variables
        let currentTab = 'dashboard';
        const selectedFaces = new Set();
        const selectedObjects = new Set();
        const selectedDiscoveries = new Set();
        window.currentIgnoredLabels = [];
        
        // Phase 2: Multi-select state
        let lastSelectedObject = null;
        let discoveryData = [];
        let detectedData = [];
        let currentZoomImages = [];
        let currentZoomIndex = 0;
        let undoStack = [];
        let currentZoomDetectionId = null;  // Store detection ID for zoom modal actions
        
        // Multi-select state for config
        let allYoloClassesConfig = [];
        let selectedObjectLabels = [];
        
        // Theme Management
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            document.getElementById('themeToggle').textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }

        // Load saved theme immediately
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);

        // Check Ring authentication on page load
        async function checkRingAuthStatus() {
            try {
                const response = await fetch('/api/ring/status');
                const data = await response.json();
                if (!data.authenticated) {
                    document.getElementById('alertBanner').style.display = 'block';
                }
            } catch (error) {
                console.error('Failed to check Ring status:', error);
            }
        }
        
        // Helper function for tab labels
        function getTabLabel(tabName) {
            const labels = {
                'dashboard': 'üìä Dashboard',
                'analytics': 'üìà Analytics',
                'metrics': 'üìä Metrics',
                'storage': 'üíæ Storage',
                'videos': 'üé• Videos',
                'review': 'üè∑Ô∏è Review & Label',
                'ring': 'üîî Ring Setup',
                'faces': 'üë§ Face Training',
                'config': '‚öôÔ∏è Configuration',
                'logs': 'üìã Logs'
            };
            return labels[tabName] || tabName;
        }

        // Tab Switching
        function switchTab(tabName) {
            currentTab = tabName; // Track the current tab
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Find and activate the tab button
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                if (tab.textContent.includes(getTabLabel(tabName))) {
                    tab.classList.add('active');
                }
            });
            
            document.getElementById(tabName).classList.add('active');

            // Load tab-specific data
            if (tabName === 'videos') loadVideos();
            if (tabName === 'storage') loadStorageData();
            if (tabName === 'review') {
                loadDiscoveries();
                loadUnknownFaces();
                loadDetectedObjects();
            }
            if (tabName === 'ring') loadRingStatus();
            if (tabName === 'faces') loadFaces();
            if (tabName === 'config') loadConfig();
            if (tabName === 'logs') startLogStream();
        }

        // API Calls
        let refreshInterval = null;
        let currentRefreshRate = 5000;
        
        function updateRefreshRate() {
            const select = document.getElementById('refreshRate');
            currentRefreshRate = parseInt(select.value);
            
            // Restart interval with new rate
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = setInterval(() => {
                    fetchStatus();
                    fetchStats();
                    if (currentTab === 'videos') {
                        loadVideos();
                    }
                }, currentRefreshRate);
            }
        }
        
        let schedulerCountdownInterval = null;
        
        function updateSchedulerBadge(scheduler) {
            const badge = document.getElementById('schedulerBadge');
            const countdown = document.getElementById('schedulerCountdown');
            
            if (!scheduler || !scheduler.enabled) {
                badge.style.display = 'none';
                if (schedulerCountdownInterval) {
                    clearInterval(schedulerCountdownInterval);
                    schedulerCountdownInterval = null;
                }
                return;
            }
            
            badge.style.display = 'inline-flex';
            badge.classList.remove('disabled');
            
            if (!scheduler.next_run) {
                countdown.textContent = 'Starting...';
                return;
            }
            
            // Start countdown timer if not already running
            if (!schedulerCountdownInterval) {
                schedulerCountdownInterval = setInterval(() => {
                    updateCountdown(scheduler.next_run);
                }, 1000);
            }
            
            updateCountdown(scheduler.next_run);
        }
        
        function updateCountdown(nextRunISO) {
            const countdown = document.getElementById('schedulerCountdown');
            const nextRun = new Date(nextRunISO);
            const now = new Date();
            const diffMs = nextRun - now;
            
            if (diffMs <= 0) {
                countdown.textContent = 'Running...';
                return;
            }
            
            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
            
            countdown.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        async function fetchStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                
                const statusBadge = document.getElementById('statusBadge');
                const dashboardProgress = document.getElementById('dashboardProgress');
                
                // Update scheduler badge
                if (data.scheduler) {
                    updateSchedulerBadge(data.scheduler);
                }
                
                if (data.is_processing && data.processing_progress) {
                    const prog = data.processing_progress;
                    const percent = prog.videos_total > 0 ? 
                        Math.round((prog.videos_processed / prog.videos_total) * 100) : 0;
                    
                    // Update status badge with progress and current step
                    const stepText = prog.current_step ? `<br><span style="font-size: 0.75em; opacity: 0.9;">${prog.current_step}</span>` : '';
                    statusBadge.innerHTML = `‚öôÔ∏è Processing <span style="font-size: 0.8em">(${prog.videos_processed}/${prog.videos_total})</span>${stepText}`;
                    statusBadge.className = 'status-badge processing';
                    
                    // Show/hide buttons in header
                    document.getElementById('stopProcessingBtn').style.display = 'inline-block';
                    
                    // Update detailed dashboard view
                    if (dashboardProgress) {
                        const elapsed = prog.time_elapsed ? formatTime(prog.time_elapsed) : '0s';
                        const remaining = prog.time_remaining ? formatTime(prog.time_remaining) : '---';
                        
                        dashboardProgress.innerHTML = `
                            <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 1rem;">
                                <div style="margin-bottom: 0.5rem;"><strong>Current Video:</strong> ${prog.current_video || 'Starting...'}</div>
                                <div style="margin-bottom: 0.5rem;"><strong>Operation:</strong> ${prog.current_step || 'Initializing...'}</div>
                                <div style="margin-bottom: 0.5rem;"><strong>Progress:</strong> ${prog.videos_processed}/${prog.videos_total} videos (${percent}%)</div>
                                <div style="background: var(--bg-card); border-radius: 4px; height: 20px; overflow: hidden; margin-bottom: 0.5rem;">
                                    <div style="background: var(--accent-color); height: 100%; width: ${percent}%; transition: width 0.3s ease;"></div>
                                </div>
                                <div style="display: flex; justify-content: space-between; font-size: 0.875rem; color: var(--text-secondary);">
                                    <span>‚è± Elapsed: ${elapsed}</span>
                                    <span>‚è≥ Est. Remaining: ${remaining}</span>
                                </div>
                            </div>
                        `;
                    }
                } else {
                    statusBadge.textContent = 'Idle';
                    statusBadge.className = 'status-badge idle';
                    document.getElementById('stopProcessingBtn').style.display = 'none';
                    if (dashboardProgress) {
                        dashboardProgress.innerHTML = '';
                    }
                }
                
                document.getElementById('lastRun').textContent = data.last_run ? 
                    new Date(data.last_run).toLocaleString() : 'Never';
            } catch (error) {
                console.error('Failed to fetch status:', error);
            }
        }
        
        function formatTime(seconds) {
            if (seconds < 60) return `${seconds}s`;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            if (mins < 60) return `${mins}m ${secs}s`;
            const hours = Math.floor(mins / 60);
            const remainMins = mins % 60;
            return `${hours}h ${remainMins}m`;
        }
        
        async function stopProcessing() {
            if (!confirm('Stop processing?\n\nWill finish current video and stop gracefully.')) {
                return;
            }
            
            try {
                const response = await fetch('/api/stop', { method: 'POST' });
                const data = await response.json();
                alert(data.message);
                fetchStatus();
            } catch (error) {
                console.error('Failed to stop processing:', error);
                alert('Failed to stop processing');
            }
        }

        async function fetchStats() {
            try {
                const response = await fetch('/api/stats');
                const stats = await response.json();
                
                let total = 0;
                let html = '<div class="face-list">';
                
                for (const [category, count] of Object.entries(stats)) {
                    total += count;
                    html += `
                        <div class="face-item">
                            <div>
                                <div class="face-name">${category}</div>
                            </div>
                            <div class="stat-value" style="font-size: 1.5rem; margin: 0;">${count}</div>
                        </div>
                    `;
                }
                
                html += '</div>';
                
                document.getElementById('totalVideos').textContent = total;
                document.getElementById('totalCategories').textContent = Object.keys(stats).length;
                document.getElementById('statsChart').innerHTML = html;
            } catch (error) {
                console.error('Failed to fetch stats:', error);
            }
        }

        async function loadRingStatus() {
            try {
                const response = await fetch('/api/ring/status');
                const data = await response.json();
                
                const statusDiv = document.getElementById('ringStatus');
                if (data.authenticated) {
                    statusDiv.innerHTML = `
                        <div style="color: var(--success-color); font-size: 3rem; margin-bottom: 1rem;">‚úì</div>
                        <div style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.5rem;">Ring Authenticated</div>
                        <div style="color: var(--text-secondary);">Token is saved and valid</div>
                        <button class="btn" style="margin-top: 1rem; background: var(--danger-color);" onclick="deleteRingToken()">Delete Token</button>
                    `;
                    document.getElementById('ringAuthCard').style.display = 'none';
                } else {
                    statusDiv.innerHTML = `
                        <div style="color: var(--warning-color); font-size: 3rem; margin-bottom: 1rem;">‚ö†</div>
                        <div style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.5rem;">Not Authenticated</div>
                        <div style="color: var(--text-secondary);">Please authenticate with Ring below</div>
                    `;
                    document.getElementById('ringAuthCard').style.display = 'block';
                    
                    // Pre-fill credentials from environment if available
                    if (data.username) {
                        document.getElementById('ringUsername').value = data.username;
                        document.getElementById('ringUsername').readOnly = true;
                    }
                    if (data.has_password) {
                        document.getElementById('ringPassword').placeholder = "Using password from environment";
                    }
                }
            } catch (error) {
                console.error('Failed to load Ring status:', error);
            }
        }

        async function authenticateRing() {
            let username = document.getElementById('ringUsername').value;
            let password = document.getElementById('ringPassword').value;
            const code2fa = document.getElementById('ring2faCode').value;
            
            // Use null to signal backend to use environment variables
            if (!username) username = null;
            if (!password) password = null;
            
            const btn = document.getElementById('ringAuthBtn');
            const msg = document.getElementById('ringAuthMessage');
            
            btn.disabled = true;
            btn.textContent = 'Authenticating...';
            msg.innerHTML = '';
            
            try {
                const response = await fetch('/api/ring/auth', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: username,
                        password: password,
                        code_2fa: code2fa || null
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    msg.innerHTML = `<div style="color: var(--success-color); padding: 1rem; background: rgba(72, 187, 120, 0.1); border-radius: 6px;">
                        ‚úì ${data.message}
                    </div>`;
                    // Hide alert banner
                    document.getElementById('alertBanner').style.display = 'none';
                    setTimeout(() => {
                        loadRingStatus();
                        document.getElementById('ringUsername').value = '';
                        document.getElementById('ringPassword').value = '';
                        document.getElementById('ring2faCode').value = '';
                        document.getElementById('ring2faGroup').style.display = 'none';
                    }, 2000);
                } else if (data.status === 'needs_2fa') {
                    document.getElementById('ring2faGroup').style.display = 'block';
                    document.getElementById('ring2faCode').focus();
                    msg.innerHTML = `<div style="color: var(--success-color); padding: 1rem; background: rgba(72, 187, 120, 0.1); border-radius: 6px;">
                        ‚úì Ring has sent a verification code!<br>
                        <strong style="margin-top: 0.5rem; display: block;">${data.message}</strong><br>
                        <span style="font-size: 0.875rem; margin-top: 0.5rem; display: block;">Enter the code in the field below and click Submit.</span>
                    </div>`;
                    btn.textContent = 'Submit 2FA Code';
                } else {
                    msg.innerHTML = `<div style="color: var(--danger-color); padding: 1rem; background: rgba(245, 101, 101, 0.1); border-radius: 6px;">
                        ‚úó ${data.message || 'Authentication failed'}
                    </div>`;
                }
            } catch (error) {
                msg.innerHTML = `<div style="color: var(--danger-color); padding: 1rem; background: rgba(245, 101, 101, 0.1); border-radius: 6px;">
                    ‚úó Error: ${error.message}
                </div>`;
            } finally {
                btn.disabled = false;
                if (btn.textContent === 'Authenticating...') {
                    btn.textContent = 'Authenticate with Ring';
                }
            }
        }

        async function deleteRingToken() {
            if (!confirm('Are you sure you want to delete the Ring authentication token? You will need to re-authenticate.')) {
                return;
            }
            
            try {
                // This would need a backend endpoint to delete the token
                alert('Token deletion coming soon. For now, use SSH: rm /mnt/user/appdata/crittercatcher/ring_token.json');
            } catch (error) {
                alert('Failed to delete token');
            }
        }

        async function loadVideos() {
            try {
                const response = await fetch('/api/videos?limit=50');
                const videos = await response.json();
                
                const grid = document.getElementById('videoGrid');
                if (videos.length === 0) {
                    grid.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 2rem;">No videos found</p>';
                    return;
                }
                
                grid.innerHTML = videos.map(video => `
                    <div class="video-card">
                        <div class="video-thumbnail">üé•</div>
                        <div class="video-info">
                            <span class="video-category">${video.category}</span>
                            <div class="video-title">${video.filename}</div>
                            <div class="video-date">${new Date(video.modified).toLocaleString()}</div>
                        </div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Failed to load videos:', error);
            }
        }

        async function loadStorageData() {
            try {
                const response = await fetch('/api/storage');
                const data = await response.json();
                
                const listContainer = document.getElementById('storageList');
                
                if (!data.categories || data.categories.length === 0) {
                    listContainer.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 2rem;">No sorted videos found</p>';
                    return;
                }
                
                // Display summary
                let html = `
                    <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 1rem; display: flex; justify-content: space-around; text-align: center;">
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: var(--accent-color);">${data.total_videos}</div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">Total Videos</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: var(--accent-color);">${data.total_size_gb.toFixed(2)} GB</div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">Total Size</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: var(--accent-color);">${data.categories.length}</div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">Categories</div>
                        </div>
                    </div>
                `;
                
                // Display each category
                data.categories.forEach(cat => {
                    const sizeDisplay = cat.size_mb > 1000 ? 
                        `${(cat.size_mb / 1024).toFixed(2)} GB` : 
                        `${cat.size_mb.toFixed(2)} MB`;
                    
                    html += `
                        <div class="face-item" style="display: flex; align-items: center; justify-content: space-between;">
                            <div style="flex: 1;">
                                <div class="face-name">üìÅ ${cat.category}</div>
                                <div class="face-count">${cat.video_count} videos ‚Ä¢ ${sizeDisplay}</div>
                            </div>
                            <button class="btn" onclick="deleteCategory('${cat.path}', '${cat.category}')" 
                                    style="background: var(--danger-color);">
                                üóëÔ∏è Delete
                            </button>
                        </div>
                    `;
                });
                
                listContainer.innerHTML = html;
            } catch (error) {
                console.error('Failed to load storage data:', error);
                document.getElementById('storageList').innerHTML = 
                    '<p style="color: var(--danger-color); text-align: center; padding: 2rem;">Failed to load storage data</p>';
            }
        }
        
        async function deleteCategory(path, categoryName) {
            if (!confirm(`Delete all videos in "${categoryName}"?\n\nThis will permanently delete all videos and their metadata. This cannot be undone.`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/storage/${encodeURIComponent(path)}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    alert(`‚úì ${data.message}`);
                    loadStorageData(); // Refresh the list
                    fetchStats(); // Update main stats
                } else {
                    alert(`‚úó Failed to delete: ${data.detail || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Failed to delete category:', error);
                alert('‚úó Failed to delete category');
            }
        }

        async function loadFaces() {
            try {
                const response = await fetch('/api/faces');
                const faces = await response.json();
                
                const list = document.getElementById('faceList');
                if (faces.length === 0) {
                    list.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 2rem;">No trained faces yet</p>';
                    return;
                }
                
                list.innerHTML = faces.map(face => `
                    <div class="face-item">
                        <div>
                            <div class="face-name">üë§ ${face.name}</div>
                            <div class="face-count">${face.image_count} training images</div>
                        </div>
                        <button class="btn" onclick="trainFace('${face.name}')">Train</button>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Failed to load faces:', error);
            }
        }

        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                // Defensive checks for config structure
                if (!data.config || !data.config.detection) {
                    throw new Error('Invalid configuration structure');
                }
                
                const detection = data.config.detection;
                const objectLabels = detection.object_labels || [];
                selectedObjectLabels = [...objectLabels]; // Store current labels
                const confidence = detection.confidence_threshold || 0.25;
                const objectFrames = detection.object_frames || 5;
                const faceTolerance = detection.face_tolerance || 0.6;
                const faceFrames = detection.face_frames || 10;
                const faceModel = detection.face_model || 'hog';
                const priority = detection.priority || 'people';
                const discoveryMode = detection.discovery_mode !== undefined ? detection.discovery_mode : true;
                const discoveryThreshold = detection.discovery_threshold || 0.30;
                const ignoredLabels = detection.ignored_labels || [];
                
                // Image Review settings
                const imageReview = data.config.image_review || {};
                const autoConfirmThreshold = imageReview.auto_confirm_threshold || 0.85;
                const maxConfirmed = imageReview.max_confirmed_images || 200;
                
                // Specialized Detection settings
                const specializedEnabled = data.config.specialized_detection?.enabled || false;
                
                // Store in memory for editing
                window.currentIgnoredLabels = [...ignoredLabels];
                
                const form = document.getElementById('configForm');
                form.innerHTML = `
                    <h3 style="margin-bottom: 1rem; color: var(--text-primary);">üéØ Object Detection</h3>
                    
                    <div class="form-group">
                        <label class="form-label">
                            Confidence Threshold: <strong id="confidenceValue">${confidence}</strong>
                        </label>
                        <input type="range" id="confidenceThreshold" class="form-input" 
                               value="${confidence}" 
                               step="0.05" min="0.1" max="0.9" 
                               oninput="document.getElementById('confidenceValue').textContent = this.value"
                               style="width: 100%;">
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Lower (0.1) = More detections, less accurate. Higher (0.9) = Fewer detections, more accurate. Recommended: 0.25-0.4
                        </p>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">
                            Object Detection Frames: <strong id="objectFramesValue">${objectFrames}</strong>
                        </label>
                        <input type="range" id="objectFrames" class="form-input" 
                               value="${objectFrames}" 
                               step="1" min="3" max="20" 
                               oninput="document.getElementById('objectFramesValue').textContent = this.value"
                               style="width: 100%;">
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Number of video frames to analyze for object detection. More frames = more accurate but slower processing. Recommended: 5-10
                        </p>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Objects to Detect (Read-Only)</label>
                        <div style="padding: 0.75rem; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                            <div id="objectLabelsDisplay">
                                ${objectLabels.length > 0 ? objectLabels.map(label => `<span style="display: inline-block; background: var(--primary-color); color: white; padding: 0.25rem 0.5rem; border-radius: 4px; margin: 0.25rem; font-size: 0.875rem;">${label}</span>`).join('') : '<span style="color: var(--text-secondary);">No YOLO classes enabled</span>'}
                            </div>
                        </div>
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            ‚ÑπÔ∏è Objects are managed in the <a href="/species.html" style="color: var(--primary-color);">Species Training</a> page. Enable YOLO classes there by checking the box next to each class.
                        </p>
                    </div>
                    
                    <hr style="margin: 2rem 0; border: none; border-top: 1px solid var(--border-color);">
                    
                    <h3 style="margin-bottom: 1rem; color: var(--text-primary);">üîç Discovery Mode</h3>
                    
                    <div class="form-group">
                        <label class="form-label" style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="checkbox" id="discoveryMode" ${discoveryMode ? 'checked' : ''} style="width: auto;">
                            Enable Discovery Mode
                        </label>
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Automatically detect new objects in videos and suggest them for tracking. Great for finding animals you didn't know visit!
                        </p>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">
                            Discovery Threshold: <strong id="discoveryThresholdValue">${discoveryThreshold}</strong>
                        </label>
                        <input type="range" id="discoveryThreshold" class="form-input" 
                               value="${discoveryThreshold}" 
                               step="0.05" min="0.2" max="0.5" 
                               oninput="document.getElementById('discoveryThresholdValue').textContent = this.value"
                               style="width: 100%;">
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Higher threshold = fewer but more confident discoveries. Recommended: 0.30
                        </p>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Blacklist (objects to ignore)</label>
                        <div id="blacklistContainer" style="margin-bottom: 0.5rem;">
                            ${ignoredLabels.map((label, index) => `
                                <span style="display: inline-block; background: var(--danger-color); color: white; padding: 0.25rem 0.5rem; border-radius: 4px; margin: 0.25rem; font-size: 0.875rem;">
                                    ${label} <button onclick="removeFromBlacklistByIndex(${index})" style="background: none; border: none; color: white; cursor: pointer; margin-left: 0.25rem;" title="Remove ${label}">‚úï</button>
                                </span>
                            `).join('')}
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <input type="text" id="newBlacklistItem" class="form-input" placeholder="Add label to blacklist" style="flex: 1;">
                            <button class="btn btn-small" onclick="addToBlacklist()">Add</button>
                        </div>
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Objects in the blacklist won't be suggested as discoveries (e.g., cloud, grass, tree)
                        </p>
                    </div>
                    
                    <hr style="margin: 2rem 0; border: none; border-top: 1px solid var(--border-color);">
                    
                    <h3 style="margin-bottom: 1rem; color: var(--text-primary);">üñºÔ∏è Image Review Settings</h3>
                    
                    <div class="form-group">
                        <label class="form-label">
                            Auto-Confirm Threshold: <strong id="autoConfirmThresholdValue">${autoConfirmThreshold}</strong>
                        </label>
                        <input type="range" id="autoConfirmThreshold" class="form-input" 
                               value="${autoConfirmThreshold}" 
                               step="0.05" min="0.50" max="1.00" 
                               oninput="document.getElementById('autoConfirmThresholdValue').textContent = this.value"
                               style="width: 100%;">
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Detections with confidence ‚â• this threshold are automatically confirmed and bypass manual review. Recommended: 0.80-0.90
                        </p>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">
                            Max Confirmed Images per Label: <strong id="maxConfirmedValue">${maxConfirmed}</strong>
                        </label>
                        <input type="range" id="maxConfirmed" class="form-input" 
                               value="${maxConfirmed}" 
                               step="50" min="50" max="1000" 
                               oninput="document.getElementById('maxConfirmedValue').textContent = this.value"
                               style="width: 100%;">
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Maximum confirmed images kept per label. Older images are automatically deleted when limit is exceeded. Recommended: 100-300
                        </p>
                    </div>
                    
                    <hr style="margin: 2rem 0; border: none; border-top: 1px solid var(--border-color);">
                    
                    <h3 style="margin-bottom: 1rem; color: var(--text-primary);">ü¶î Specialized Species Detection</h3>
                    
                    <div class="form-group">
                        <label class="form-label" style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="checkbox" id="specializedEnabled" ${specializedEnabled ? 'checked' : ''} style="width: auto;">
                            Enable Specialized Species Detection (Stage 2)
                        </label>
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            üéØ Use trained AI models to identify specific species (e.g., Jack Russell, Goldfinch) beyond basic YOLO categories.<br>
                            <strong>Requirements:</strong> Species must be trained via Species Training page with sufficient training images.<br>
                            <strong>Effect:</strong> Videos will be sorted by specific species (e.g., /sorted/Jack_Russell/) instead of general category (e.g., /sorted/dog/).
                        </p>
                    </div>
                    
                    <hr style="margin: 2rem 0; border: none; border-top: 1px solid var(--border-color);">
                    
                    <h3 style="margin-bottom: 1rem; color: var(--text-primary);">‚è±Ô∏è Scheduler Settings</h3>
                    
                    <div class="form-group">
                        <label class="form-label" style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="checkbox" id="autoRun" ${data.config.scheduler?.auto_run === true ? 'checked' : ''} style="width: auto;" onchange="toggleIntervalDropdown()">
                            Enable Auto Run
                        </label>
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Automatically download and process videos on a schedule. If disabled, processing only runs when manually triggered.
                        </p>
                    </div>
                    
                    <div class="form-group" id="intervalGroup">
                        <label class="form-label">Run Interval</label>
                        <select id="intervalMinutes" class="form-select" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 1rem;">
                            <option value="15" ${data.config.scheduler?.interval_minutes === 15 ? 'selected' : ''}>Every 15 minutes</option>
                            <option value="30" ${data.config.scheduler?.interval_minutes === 30 ? 'selected' : ''}>Every 30 minutes</option>
                            <option value="60" ${(data.config.scheduler?.interval_minutes || 60) === 60 ? 'selected' : ''}>Every hour</option>
                            <option value="120" ${data.config.scheduler?.interval_minutes === 120 ? 'selected' : ''}>Every 2 hours</option>
                            <option value="240" ${data.config.scheduler?.interval_minutes === 240 ? 'selected' : ''}>Every 4 hours</option>
                            <option value="360" ${data.config.scheduler?.interval_minutes === 360 ? 'selected' : ''}>Every 6 hours</option>
                            <option value="720" ${data.config.scheduler?.interval_minutes === 720 ? 'selected' : ''}>Every 12 hours</option>
                            <option value="1440" ${data.config.scheduler?.interval_minutes === 1440 ? 'selected' : ''}>Every 24 hours</option>
                        </select>
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            How often to download and process videos when Auto Run is enabled.
                        </p>
                    </div>
                    
                    <hr style="margin: 2rem 0; border: none; border-top: 1px solid var(--border-color);">
                    
                    <h3 style="margin-bottom: 1rem; color: var(--text-primary);">üë§ Face Recognition</h3>
                    
                    <div class="form-group">
                        <label class="form-label">
                            Face Tolerance: <strong id="faceToleranceValue">${faceTolerance}</strong>
                        </label>
                        <input type="range" id="faceTolerance" class="form-input" 
                               value="${faceTolerance}" 
                               step="0.05" min="0.3" max="0.9" 
                               oninput="document.getElementById('faceToleranceValue').textContent = this.value"
                               style="width: 100%;">
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Lower (0.3) = Strict matching. Higher (0.9) = Lenient matching. Recommended: 0.5-0.7
                        </p>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">
                            Face Recognition Frames: <strong id="faceFramesValue">${faceFrames}</strong>
                        </label>
                        <input type="range" id="faceFrames" class="form-input" 
                               value="${faceFrames}" 
                               step="1" min="5" max="30" 
                               oninput="document.getElementById('faceFramesValue').textContent = this.value"
                               style="width: 100%;">
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            Number of video frames to analyze for face recognition. More frames = better chance of recognition but slower. Recommended: 10-15
                        </p>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Face Detection Model</label>
                        <select id="faceModel" class="form-select" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 1rem;">
                            <option value="hog" ${faceModel === 'hog' ? 'selected' : ''}>HOG (Fast, CPU-friendly)</option>
                            <option value="cnn" ${faceModel === 'cnn' ? 'selected' : ''}>CNN (Accurate, GPU recommended)</option>
                        </select>
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            HOG is faster and works well on CPU. CNN is more accurate but requires more processing power.
                        </p>
                    </div>
                    
                    <hr style="margin: 2rem 0; border: none; border-top: 1px solid var(--border-color);">
                    
                    <h3 style="margin-bottom: 1rem; color: var(--text-primary);">‚öôÔ∏è Sorting Priority</h3>
                    
                    <div class="form-group">
                        <label class="form-label">When both people and objects are detected:</label>
                        <select id="detectionPriority" class="form-select" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 1rem;">
                            <option value="people" ${priority === 'people' ? 'selected' : ''}>Prioritize People</option>
                            <option value="objects" ${priority === 'objects' ? 'selected' : ''}>Prioritize Objects</option>
                        </select>
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                            "People" = Sort by recognized person first. "Objects" = Sort by detected object first.
                        </p>
                    </div>
                    
                    <div style="margin-top: 2rem;">
                        <button class="btn" onclick="saveConfig()" style="width: 100%; padding: 1rem; font-size: 1rem;">üíæ Save Configuration</button>
                    </div>
                    <div id="configMessage" style="margin-top: 1rem;"></div>
                `;
                
                // No longer need multi-select - object labels are managed in Species Training page
                
                // Dim Discovery Mode tab if discovery mode is disabled
                const discoveryTab = document.getElementById('discoveryTab');
                if (discoveryMode) {
                    discoveryTab.classList.remove('disabled');
                } else {
                    discoveryTab.classList.add('disabled');
                }
            } catch (error) {
                console.error('Failed to load config:', error);
                document.getElementById('configForm').innerHTML = `
                    <div style="padding: 2rem; text-align: center;">
                        <div style="font-size: 3rem; margin-bottom: 1rem; color: var(--danger-color);">‚ö†Ô∏è</div>
                        <h3 style="color: var(--danger-color); margin-bottom: 1rem;">Failed to Load Configuration</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 1rem;">${error.message}</p>
                        <p style="color: var(--text-secondary); font-size: 0.875rem;">
                            Check Docker logs: <code style="background: var(--bg-secondary); padding: 0.25rem 0.5rem; border-radius: 4px;">docker logs crittercatcher-ai</code>
                        </p>
                    </div>
                `;
            }
        }
        
        function toggleIntervalDropdown() {
            const autoRun = document.getElementById('autoRun').checked;
            const intervalGroup = document.getElementById('intervalGroup');
            if (intervalGroup) {
                intervalGroup.style.opacity = autoRun ? '1' : '0.5';
                document.getElementById('intervalMinutes').disabled = !autoRun;
            }
        }
        
        async function saveConfig() {
            try {
                // Load current config to preserve object_labels (managed in Species Training)
                const currentResponse = await fetch('/api/config');
                const currentData = await currentResponse.json();
                const currentObjectLabels = currentData.config?.detection?.object_labels || [];
                
                const config = {
                    config: {
                        paths: {
                            downloads: '/data/downloads',
                            sorted: '/data/sorted',
                            face_encodings: '/data/faces/encodings.pkl'
                        },
                        ring: {
                            download_hours: 24,
                            download_limit: null
                        },
                        scheduler: {
                            auto_run: document.getElementById('autoRun').checked,
                            interval_minutes: parseInt(document.getElementById('intervalMinutes').value)
                        },
                        detection: {
                            object_labels: currentObjectLabels,  // Preserve existing labels from Species Training
                            confidence_threshold: parseFloat(document.getElementById('confidenceThreshold').value),
                            object_frames: parseInt(document.getElementById('objectFrames').value),
                            discovery_mode: document.getElementById('discoveryMode').checked,
                            discovery_threshold: parseFloat(document.getElementById('discoveryThreshold').value),
                            ignored_labels: window.currentIgnoredLabels || [],
                            face_tolerance: parseFloat(document.getElementById('faceTolerance').value),
                            face_frames: parseInt(document.getElementById('faceFrames').value),
                            face_model: document.getElementById('faceModel').value,
                            priority: document.getElementById('detectionPriority').value
                        },
                        image_review: {
                            auto_confirm_threshold: parseFloat(document.getElementById('autoConfirmThreshold').value),
                            max_confirmed_images: parseInt(document.getElementById('maxConfirmed').value)
                        },
                        specialized_detection: {
                            enabled: document.getElementById('specializedEnabled').checked
                        },
                        run_once: false,
                        interval_minutes: parseInt(document.getElementById('intervalMinutes').value)  // Keep for backwards compatibility
                    }
                };
                
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                const message = result.message || 'Configuration saved successfully';
                
                // Update Discovery Mode tab dimming immediately
                const discoveryMode = document.getElementById('discoveryMode').checked;
                const discoveryTab = document.getElementById('discoveryTab');
                if (discoveryMode) {
                    discoveryTab.classList.remove('disabled');
                } else {
                    discoveryTab.classList.add('disabled');
                }
                
                const msgDiv = document.getElementById('configMessage');
                msgDiv.innerHTML = `<div style="color: var(--success-color); padding: 1rem; background: rgba(72, 187, 120, 0.1); border-radius: 6px;">
                    ‚úì ${message}<br>
                    <span style="font-size: 0.875rem; margin-top: 0.5rem; display: block;">Changes will take effect on the next processing run.</span>
                </div>`;
                
            } catch (error) {
                console.error('Failed to save config:', error);
                const msgDiv = document.getElementById('configMessage');
                msgDiv.innerHTML = `<div style="color: var(--danger-color); padding: 1rem; background: rgba(245, 101, 101, 0.1); border-radius: 6px;">
                    ‚úó Failed to save configuration: ${error.message}
                </div>`;
            }
        }
        
        function addToBlacklist() {
            const input = document.getElementById('newBlacklistItem');
            const label = input.value.trim().toLowerCase();
            
            if (!label) return;
            
            if (!window.currentIgnoredLabels) window.currentIgnoredLabels = [];
            if (window.currentIgnoredLabels.includes(label)) {
                alert('Label already in blacklist');
                return;
            }
            
            window.currentIgnoredLabels.push(label);
            input.value = '';
            updateBlacklistUI(); // Update UI only, don't reload from server
        }
        
        function removeFromBlacklist(label) {
            if (!window.currentIgnoredLabels) window.currentIgnoredLabels = [];
            window.currentIgnoredLabels = window.currentIgnoredLabels.filter(l => l !== label);
            updateBlacklistUI(); // Update UI only, don't reload from server
        }
        
        function removeFromBlacklistByIndex(index) {
            if (!window.currentIgnoredLabels) window.currentIgnoredLabels = [];
            window.currentIgnoredLabels.splice(index, 1);
            updateBlacklistUI(); // Update UI only, don't reload from server
        }
        
        function updateBlacklistUI() {
            const container = document.getElementById('blacklistContainer');
            if (!container) return;
            
            if (!window.currentIgnoredLabels || window.currentIgnoredLabels.length === 0) {
                container.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.875rem;">No items in blacklist</span>';
                return;
            }
            
            container.innerHTML = window.currentIgnoredLabels.map((label, index) => `
                <span style="display: inline-block; background: var(--danger-color); color: white; padding: 0.25rem 0.5rem; border-radius: 4px; margin: 0.25rem; font-size: 0.875rem;">
                    ${label} <button onclick="removeFromBlacklistByIndex(${index})" style="background: none; border: none; color: white; cursor: pointer; margin-left: 0.25rem;" title="Remove ${label}">‚úï</button>
                </span>
            `).join('');
        }
        
        // Multi-select functions for Object Labels
        async function loadYoloClassesForConfig() {
            try {
                const response = await fetch('/api/yolo_classes');
                const data = await response.json();
                allYoloClassesConfig = data.classes;
                renderObjectLabelsMultiSelectOptions();
            } catch (error) {
                console.error('Failed to load YOLO classes:', error);
            }
        }
        
        function renderObjectLabelsMultiSelectOptions() {
            const optionsDiv = document.getElementById('objectLabelsOptions');
            if (!optionsDiv) return;
            
            optionsDiv.innerHTML = allYoloClassesConfig.map(cls => `
                <div class="multi-select-option" onclick="toggleObjectLabelSelection('${cls}', event)">
                    <input type="checkbox" id="obj_class_${cls}" ${selectedObjectLabels.includes(cls) ? 'checked' : ''}>
                    <label for="obj_class_${cls}" style="cursor: pointer; user-select: none;">${cls}</label>
                </div>
            `).join('');
        }
        
        function toggleObjectLabelsMultiSelect() {
            const dropdown = document.getElementById('objectLabelsDropdown');
            if (!dropdown) return;
            dropdown.classList.toggle('active');
            if (dropdown.classList.contains('active')) {
                const search = document.getElementById('objectLabelsSearch');
                if (search) search.focus();
            }
        }
        
        function toggleObjectLabelSelection(className, event) {
            event.stopPropagation();
            const checkbox = document.getElementById(`obj_class_${className}`);
            if (!checkbox) return;
            
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                if (!selectedObjectLabels.includes(className)) {
                    selectedObjectLabels.push(className);
                }
            } else {
                selectedObjectLabels = selectedObjectLabels.filter(c => c !== className);
            }
            
            updateObjectLabelsDisplayTags();
        }
        
        function updateObjectLabelsDisplayTags() {
            const display = document.getElementById('objectLabelsDisplay');
            if (!display) return;
            
            if (selectedObjectLabels.length === 0) {
                display.innerHTML = '<span class="placeholder-text">Select YOLO classes...</span>';
            } else {
                display.innerHTML = selectedObjectLabels.map(cls => `
                    <div class="selected-tag">
                        ${cls}
                        <span class="remove" onclick="removeObjectLabelTag('${cls}', event)">√ó</span>
                    </div>
                `).join('');
            }
        }
        
        function removeObjectLabelTag(className, event) {
            event.stopPropagation();
            selectedObjectLabels = selectedObjectLabels.filter(c => c !== className);
            const checkbox = document.getElementById(`obj_class_${className}`);
            if (checkbox) checkbox.checked = false;
            updateObjectLabelsDisplayTags();
        }
        
        function filterObjectLabelsMultiSelect() {
            const search = document.getElementById('objectLabelsSearch');
            if (!search) return;
            
            const searchText = search.value.toLowerCase();
            const options = document.querySelectorAll('#objectLabelsOptions .multi-select-option');
            
            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                option.style.display = text.includes(searchText) ? 'flex' : 'none';
            });
        }
        
        function handleObjectLabelsOutsideClick(e) {
            const container = document.getElementById('objectLabelsContainer');
            const dropdown = document.getElementById('objectLabelsDropdown');
            if (container && dropdown && !container.contains(e.target)) {
                dropdown.classList.remove('active');
            }
        }
        
        async function cleanupDownloads() {
            if (!confirm('Cleanup Downloads Folder?\\n\\nThis will process ALL videos currently in the downloads folder, regardless of age.\\n\\nVideos will be sorted based on current detection settings.\\n\\nContinue?')) {
                return;
            }
            
            try {
                const response = await fetch('/api/cleanup-downloads', { method: 'POST' });
                const data = await response.json();
                alert(data.message);
                fetchStatus();
            } catch (error) {
                console.error('Failed to trigger cleanup:', error);
                alert('Failed to start cleanup');
            }
        }

        async function returnVideosToDownloads() {
            if (!confirm('Return all videos to downloads?\\n\\nThis will:\\n- Move all sorted videos back to downloads\\n- Delete sorted directories\\n- NOT trigger automatic processing\\n\\nUse "Cleanup Downloads" or "Process Now" afterwards to reprocess them.\\n\\nContinue?')) {
                return;
            }
            
            try {
                const response = await fetch('/api/reprocess', { method: 'POST' });
                const data = await response.json();
                alert(data.message);
                fetchStatus();
            } catch (error) {
                console.error('Failed to return videos:', error);
                alert('Failed to return videos to downloads');
            }
        }

        async function downloadAllVideos() {
            const timeRange = document.getElementById('timeRange').value;
            const timeRangeText = document.getElementById('timeRange').selectedOptions[0].text;
            
            if (!confirm(`Download all videos from ${timeRangeText}?\n\nThis will download any videos not already on your system. Existing videos will be skipped.`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/download-all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ time_range: timeRange })
                });
                const data = await response.json();
                alert(data.message);
                fetchStatus();
            } catch (error) {
                console.error('Failed to trigger download:', error);
                alert('Failed to start download');
            }
        }
        
        async function triggerProcessing() {
            try {
                const response = await fetch('/api/process', { method: 'POST' });
                const data = await response.json();
                alert(data.message);
                fetchStatus();
            } catch (error) {
                console.error('Failed to trigger processing:', error);
                alert('Failed to start processing');
            }
        }

        async function trainFace(name) {
            try {
                const response = await fetch(`/api/faces/train?person_name=${name}`, { method: 'POST' });
                const data = await response.json();
                alert(data.message);
            } catch (error) {
                console.error('Failed to train face:', error);
                alert('Failed to start training');
            }
        }

        async function uploadFiles() {
            const personName = document.getElementById('personName').value;
            if (!personName) {
                alert('Please enter a person name first');
                return;
            }

            const files = document.getElementById('fileInput').files;
            for (const file of files) {
                const formData = new FormData();
                formData.append('file', file);
                
                try {
                    const response = await fetch(`/api/faces/upload?person_name=${personName}`, {
                        method: 'POST',
                        body: formData
                    });
                    const data = await response.json();
                    console.log(data.message);
                } catch (error) {
                    console.error('Upload failed:', error);
                }
            }
            
            alert(`Uploaded ${files.length} image(s) for ${personName}`);
            loadFaces();
        }

        // Review & Label Tab Functions
        
        async function loadDiscoveries() {
            try {
                const response = await fetch('/api/discoveries');
                const data = await response.json();
                const container = document.getElementById('discoveriesContainer');
                const badge = document.getElementById('discoveryBadge');
                const filters = document.getElementById('discoveryFilters');
                
                if (!data.discoveries || data.discoveries.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 2rem;">No new discoveries yet. Enable Discovery Mode in Configuration and process some videos!</p>';
                    badge.style.display = 'none';
                    filters.style.display = 'none';
                    return;
                }
                
                // Show badge and filters
                badge.textContent = `${data.discoveries.length} new!`;
                badge.className = 'status-badge processing';
                badge.style.display = 'inline-flex';
                filters.style.display = 'flex';
                
                // Store data globally for filtering
                discoveryData = data.discoveries;
                renderDiscoveries(discoveryData);
                selectedDiscoveries.clear();
                
                
            } catch (error) {
                console.error('Failed to load discoveries:', error);
            }
        }
        
        function toggleDiscovery(label) {
            const checkbox = document.getElementById(`discovery-${label}`);
            if (checkbox.checked) {
                selectedDiscoveries.add(label);
            } else {
                selectedDiscoveries.delete(label);
            }
        }
        
        async function approveDiscoveries() {
            if (selectedDiscoveries.size === 0) {
                alert('Please select at least one discovery to track');
                return;
            }
            
            try {
                const response = await fetch('/api/discoveries/approve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ labels: Array.from(selectedDiscoveries) })
                });
                
                const data = await response.json();
                alert(data.message + '\n\nView and manage these objects in the Species Training page.');
                loadDiscoveries(); // Reload
                selectedDiscoveries.clear(); // Clear selection
                
            } catch (error) {
                console.error('Failed to approve discoveries:', error);
                alert('Failed to approve discoveries');
            }
        }
        
        async function ignoreDiscoveries() {
            if (selectedDiscoveries.size === 0) {
                alert('Please select at least one discovery');
                return;
            }
            
            const labelText = Array.from(selectedDiscoveries).join(', ');
            if (!confirm(`Blacklist "${labelText}"?\n\nThe AI correctly identified these objects, but you're not interested in tracking them. They won't be suggested again.`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/discoveries/ignore', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ labels: Array.from(selectedDiscoveries) })
                });
                
                const data = await response.json();
                alert(data.message);
                loadDiscoveries(); // Reload
                
            } catch (error) {
                console.error('Failed to ignore discoveries:', error);
                alert('Failed to ignore discoveries');
            }
        }
        
        async function relabelDiscoveries() {
            if (selectedDiscoveries.size === 0) {
                alert('Please select discoveries to relabel');
                return;
            }
            
            if (selectedDiscoveries.size > 1) {
                alert('Please select only ONE discovery at a time to relabel');
                return;
            }
            
            const oldLabel = Array.from(selectedDiscoveries)[0];
            const newLabel = prompt(
                `The AI thinks this is "${oldLabel}" but you disagree.\n\n` +
                `What is the CORRECT label for these images?\n\n` +
                `Examples: hedgehog, fox, cat, person, car, etc.`,
                oldLabel
            );
            
            if (newLabel === null || newLabel.trim() === '') {
                return; // Cancelled or empty
            }
            
            const correctedLabel = newLabel.trim().toLowerCase();
            
            if (correctedLabel === oldLabel) {
                alert('That\'s the same label! No changes made.');
                return;
            }
            
            try {
                // First, approve the discovery with the corrected label
                const response = await fetch('/api/discoveries/approve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        labels: [correctedLabel],
                        relabel_from: oldLabel
                    })
                });
                
                const data = await response.json();
                alert(`Corrected: "${oldLabel}" ‚Üí "${correctedLabel}"\\n\\n${data.message}\\n\\nView and manage this object in the Species Training page.`);
                loadDiscoveries(); // Reload
                selectedDiscoveries.clear(); // Clear selection
                
            } catch (error) {
                console.error('Failed to relabel discovery:', error);
                alert('Failed to relabel discovery');
            }
        }
        
        async function loadUnknownFaces() {
            try {
                const response = await fetch('/api/unknown_faces');
                const data = await response.json();
                const container = document.getElementById('unknownFacesContainer');
                
                if (!data.groups || data.groups.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 2rem;">No unknown faces found. Process some videos to see faces here!</p>';
                    return;
                }
                
                let html = '';
                
                for (const group of data.groups) {
                    html += `
                        <div class="group-header">
                            <div>
                                <strong>Group ${data.groups.indexOf(group) + 1}</strong> - ${group.count} similar face(s)
                            </div>
                            <button class="btn btn-small" onclick="selectAllInGroup('${group.id}', ${JSON.stringify(group.faces.map(f => f.filename))})">Select All</button>
                        </div>
                        <div class="image-grid">
                    `;
                    
                    for (const face of group.faces) {
                        const imageSrc = `/api/unknown_faces/image/${face.filename}`;
                        html += `
                            <div class="image-item" 
                                 id="face-${face.filename}" 
                                 onclick="toggleFaceSelection('${face.filename}')"
                                 ondblclick="openZoomModal('${imageSrc}', 'Unknown Face', null); event.stopPropagation();"
                                 title="Click to select | Double-click to zoom">
                                <img src="${imageSrc}" alt="Unknown face">
                                <div class="image-overlay">${face.video_name || 'Unknown'}</div>
                            </div>
                        `;
                    }
                    
                    html += '</div>';
                }
                
                // Add labeling controls
                html += `
                    <div class="label-controls">
                        <input type="text" id="faceLabel" class="form-input" placeholder="Enter person name" style="flex: 1; min-width: 200px;">
                        <button class="btn" onclick="labelSelectedFaces('label')">Label Selected</button>
                        <button class="btn" onclick="labelSelectedFaces('ignore')" style="background: var(--danger-color);">Ignore Selected</button>
                    </div>
                `;
                
                container.innerHTML = html;
                selectedFaces.clear();
                
            } catch (error) {
                console.error('Failed to load unknown faces:', error);
            }
        }
        
        function toggleFaceSelection(filename) {
            const element = document.getElementById(`face-${filename}`);
            if (selectedFaces.has(filename)) {
                selectedFaces.delete(filename);
                element.classList.remove('selected');
            } else {
                selectedFaces.add(filename);
                element.classList.add('selected');
            }
        }
        
        function selectAllInGroup(groupId, filenames) {
            for (const filename of filenames) {
                if (!selectedFaces.has(filename)) {
                    selectedFaces.add(filename);
                    const element = document.getElementById(`face-${filename}`);
                    if (element) element.classList.add('selected');
                }
            }
        }
        
        async function labelSelectedFaces(action) {
            if (selectedFaces.size === 0) {
                alert('Please select at least one face');
                return;
            }
            
            const personName = document.getElementById('faceLabel')?.value.trim();
            if (action === 'label' && !personName) {
                alert('Please enter a person name');
                return;
            }
            
            try {
                const response = await fetch('/api/unknown_faces/label', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filenames: Array.from(selectedFaces),
                        person_name: personName,
                        action: action
                    })
                });
                
                const data = await response.json();
                alert(data.message);
                loadUnknownFaces(); // Reload
                
            } catch (error) {
                console.error('Failed to label faces:', error);
                alert('Failed to label faces');
            }
        }
        
        async function loadDetectedObjects() {
            try {
                const response = await fetch('/api/detected_objects');
                const data = await response.json();
                const container = document.getElementById('detectedObjectsContainer');
                const filters = document.getElementById('detectedFilters');
                
                if (!data.objects || data.objects.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 2rem;">No detected objects yet. Process some videos to see detections here!</p>';
                    filters.style.display = 'none';
                    return;
                }
                
                // Show filters
                filters.style.display = 'flex';
                
                // Store data globally for filtering
                detectedData = data.objects;
                renderDetectedObjects(detectedData);
                selectedObjects.clear();
                
                
            } catch (error) {
                console.error('Failed to load detected objects:', error);
            }
        }
        
        function toggleObjectSelection(detectionId, event) {
            if (event) event.stopPropagation();
            const saferId = detectionId.replace(/[^a-z0-9]/gi, '-');
            const element = document.getElementById(`object-${saferId}`);
            if (selectedObjects.has(detectionId)) {
                selectedObjects.delete(detectionId);
                element.classList.remove('selected');
            } else {
                selectedObjects.add(detectionId);
                element.classList.add('selected');
            }
        }
        
        // Image zoom modal functions
        function openZoomModal(imageSrc, label, confidence, detectionId = null) {
            const modal = document.getElementById('zoomModal');
            const modalImg = document.getElementById('zoomModalImage');
            const modalInfo = document.getElementById('zoomModalInfo');
            const modalActions = document.getElementById('zoomModalActions');
            
            modal.classList.add('show');
            modalImg.src = imageSrc;
            currentZoomDetectionId = detectionId;
            
            let infoHTML = `<strong>Label:</strong> ${label}`;
            if (confidence) {
                const conf = (confidence * 100).toFixed(1);
                infoHTML += `<br><strong>Confidence:</strong> ${conf}%`;
            }
            infoHTML += `<br><em style="font-size: 0.875rem; color: var(--text-secondary);">Click anywhere to close | ESC to close</em>`;
            
            modalInfo.innerHTML = infoHTML;
            
            // Show Confirm/Delete buttons for detected objects (when detectionId is provided)
            if (detectionId) {
                modalActions.innerHTML = `
                    <button class="btn btn-success" onclick="confirmFromZoom(event)" style="padding: 0.75rem 1.5rem;">‚úì Confirm</button>
                    <button class="btn" onclick="deleteFromZoom(event)" style="background: var(--danger-color); padding: 0.75rem 1.5rem;">‚úó Delete</button>
                `;
                modalActions.style.display = 'flex';
            } else {
                modalActions.style.display = 'none';
            }
            
            // Enable ESC key to close
            document.addEventListener('keydown', handleZoomModalEscape);
        }
        
        function closeZoomModal(event) {
            if (event) event.stopPropagation();
            const modal = document.getElementById('zoomModal');
            modal.classList.remove('show');
            currentZoomDetectionId = null;
            document.removeEventListener('keydown', handleZoomModalEscape);
        }
        
        async function confirmFromZoom(event) {
            event.stopPropagation();
            if (!currentZoomDetectionId) return;
            
            try {
                const response = await fetch('/api/detected_objects/confirm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ detections: [currentZoomDetectionId] })
                });
                
                const data = await response.json();
                alert(data.message);
                closeZoomModal();
                loadDetectedObjects();
            } catch (error) {
                console.error('Failed to confirm:', error);
                alert('Failed to confirm detection');
            }
        }
        
        async function deleteFromZoom(event) {
            event.stopPropagation();
            if (!currentZoomDetectionId) return;
            
            if (!confirm('Delete this detection?\n\nThis is incorrectly identified and will be removed.')) {
                return;
            }
            
            try {
                const [label, filename] = currentZoomDetectionId.split(':');
                const response = await fetch('/api/detected_objects/relabel', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        old_label: label,
                        new_label: '',
                        filename: filename,
                        action: 'delete'
                    })
                });
                
                if (response.ok) {
                    alert('Detection deleted');
                    closeZoomModal();
                    loadDetectedObjects();
                } else {
                    alert('Failed to delete detection');
                }
            } catch (error) {
                console.error('Failed to delete:', error);
                alert('Failed to delete detection');
            }
        }
        
        // Discovery-specific zoom modal with Enable/Blacklist actions
        function openZoomModalDiscovery(imageSrc, label, confidence, detectionId) {
            const modal = document.getElementById('zoomModal');
            const modalImg = document.getElementById('zoomModalImage');
            const modalInfo = document.getElementById('zoomModalInfo');
            const modalActions = document.getElementById('zoomModalActions');
            
            modal.classList.add('show');
            modalImg.src = imageSrc;
            currentZoomDetectionId = detectionId;
            
            let infoHTML = `<strong>Discovery:</strong> ${label}`;
            if (confidence) {
                const conf = (confidence * 100).toFixed(1);
                infoHTML += `<br><strong>Confidence:</strong> ${conf}%`;
            }
            infoHTML += `<br><em style="font-size: 0.875rem; color: var(--text-secondary);">Click anywhere to close | ESC to close</em>`;
            
            modalInfo.innerHTML = infoHTML;
            
            // Show Enable and Blacklist buttons for discoveries
            modalActions.innerHTML = `
                <button class="btn btn-success" onclick="enableFromZoom(event)" style="padding: 0.75rem 1.5rem;">‚úì Enable</button>
                <button class="btn" onclick="blacklistFromZoom(event)" style="background: var(--warning-color); color: white; padding: 0.75rem 1.5rem;">‚úó Blacklist</button>
            `;
            modalActions.style.display = 'flex';
            
            document.addEventListener('keydown', handleZoomModalEscape);
        }
        
        async function enableFromZoom(event) {
            event.stopPropagation();
            if (!currentZoomDetectionId) return;
            
            const [label] = currentZoomDetectionId.split(':');
            
            try {
                const response = await fetch('/api/discoveries/approve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ labels: [label] })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Enable failed:', errorText);
                    alert(`Failed to enable discovery: ${response.status} ${response.statusText}`);
                    return;
                }
                
                const data = await response.json();
                alert(data.message || 'Discovery enabled successfully');
                closeZoomModal();
                loadDiscoveries();
            } catch (error) {
                console.error('Failed to enable:', error);
                alert('Failed to enable discovery: ' + error.message);
            }
        }
        
        async function blacklistFromZoom(event) {
            event.stopPropagation();
            if (!currentZoomDetectionId) return;
            
            const [label] = currentZoomDetectionId.split(':');
            
            if (!confirm(`Blacklist "${label}"?\n\nThis object won't be suggested again.`)) return;
            
            try {
                const response = await fetch('/api/discoveries/ignore', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ labels: [label] })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Blacklist failed:', errorText);
                    alert(`Failed to blacklist discovery: ${response.status} ${response.statusText}`);
                    return;
                }
                
                const data = await response.json();
                alert(data.message || 'Discovery blacklisted successfully');
                closeZoomModal();
                loadDiscoveries();
            } catch (error) {
                console.error('Failed to blacklist:', error);
                alert('Failed to blacklist discovery: ' + error.message);
            }
        }
        
        function handleZoomModalEscape(event) {
            if (event.key === 'Escape') {
                closeZoomModal();
            }
        }
        
        function selectAllObjects(groupId, detectionIds) {
            for (const detectionId of detectionIds) {
                if (!selectedObjects.has(detectionId)) {
                    selectedObjects.add(detectionId);
                    const saferId = detectionId.replace(/[^a-z0-9]/gi, '-');
                    const element = document.getElementById(`object-${saferId}`);
                    if (element) element.classList.add('selected');
                }
            }
        }
        
        async function confirmSelectedObjects() {
            if (selectedObjects.size === 0) {
                alert('Please select at least one object detection');
                return;
            }
            
            if (!confirm(`Confirm ${selectedObjects.size} detection(s) as correct?\n\nThese will be moved to confirmed folder and removed from review list.`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/detected_objects/confirm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ detections: Array.from(selectedObjects) })
                });
                
                const data = await response.json();
                alert(data.message);
                
                selectedObjects.clear();
                loadDetectedObjects();
            } catch (error) {
                console.error('Failed to confirm objects:', error);
                alert('Failed to confirm some objects');
            }
        }
        
        async function deleteSelectedObjects() {
            if (selectedObjects.size === 0) {
                alert('Please select at least one object detection');
                return;
            }
            
            if (!confirm(`Delete ${selectedObjects.size} detection(s)?\n\nThese are incorrectly identified and will be removed.`)) {
                return;
            }
            
            try {
                // Parse label:filename format and group by label
                const byLabel = {};
                for (const detectionId of selectedObjects) {
                    const [label, filename] = detectionId.split(':');
                    if (!byLabel[label]) byLabel[label] = [];
                    byLabel[label].push(filename);
                }
                
                // Delete each group
                let deleted = 0;
                for (const [label, filenames] of Object.entries(byLabel)) {
                    for (const filename of filenames) {
                        const response = await fetch('/api/detected_objects/relabel', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                old_label: label,
                                new_label: '',
                                filename: filename,
                                action: 'delete'
                            })
                        });
                        if (response.ok) deleted++;
                    }
                }
                
                alert(`Deleted ${deleted} detection(s)`);
                selectedObjects.clear();
                loadDetectedObjects();
                
            } catch (error) {
                console.error('Failed to delete objects:', error);
                alert('Failed to delete some objects');
            }
        }
        
        async function relabelSelectedObjects() {
            if (selectedObjects.size === 0) {
                alert('Please select at least one object detection');
                return;
            }
            
            const newLabel = prompt(`Relabel ${selectedObjects.size} detection(s)\n\nEnter the CORRECT label for these objects:`);
            
            if (newLabel === null || newLabel.trim() === '') {
                return; // Cancelled or empty
            }
            
            const correctedLabel = newLabel.trim().toLowerCase();
            
            try {
                // Parse label:filename format and relabel each
                const byLabel = {};
                for (const detectionId of selectedObjects) {
                    const [label, filename] = detectionId.split(':');
                    if (!byLabel[label]) byLabel[label] = [];
                    byLabel[label].push(filename);
                }
                
                let relabeled = 0;
                for (const [oldLabel, filenames] of Object.entries(byLabel)) {
                    for (const filename of filenames) {
                        const response = await fetch('/api/detected_objects/relabel', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                old_label: oldLabel,
                                new_label: correctedLabel,
                                filename: filename,
                                action: 'relabel'
                            })
                        });
                        if (response.ok) relabeled++;
                    }
                }
                
                alert(`Relabeled ${relabeled} detection(s) to "${correctedLabel}"`);
                selectedObjects.clear();
                loadDetectedObjects();
                
            } catch (error) {
                console.error('Failed to relabel objects:', error);
                alert('Failed to relabel some objects');
            }
        }
        
        // Per-category actions for discoveries
        async function trackSingleDiscovery(label) {
            try {
                const response = await fetch('/api/discoveries/approve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ labels: [label] })
                });
                const data = await response.json();
                alert(data.message);
                loadDiscoveries();
            } catch (error) {
                console.error('Failed to track discovery:', error);
                alert('Failed to track discovery');
            }
        }
        
        async function blacklistSingleDiscovery(label) {
            if (!confirm(`Blacklist "${label}"?\n\nThis object won't be suggested again.`)) return;
            try {
                const response = await fetch('/api/discoveries/ignore', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ labels: [label] })
                });
                const data = await response.json();
                alert(data.message);
                loadDiscoveries();
            } catch (error) {
                console.error('Failed to blacklist discovery:', error);
                alert('Failed to blacklist discovery');
            }
        }
        
        async function relabelSingleDiscovery(label) {
            const newLabel = prompt(
                `The AI thinks this is "${label}" but you disagree.\n\n` +
                `What is the CORRECT label?`,
                label
            );
            if (newLabel === null || newLabel.trim() === '' || newLabel.trim().toLowerCase() === label) return;
            
            try {
                const response = await fetch('/api/discoveries/approve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        labels: [newLabel.trim().toLowerCase()],
                        relabel_from: label
                    })
                });
                const data = await response.json();
                alert(`Corrected: "${label}" ‚Üí "${newLabel.trim().toLowerCase()}"\n\n${data.message}`);
                loadDiscoveries();
            } catch (error) {
                console.error('Failed to relabel discovery:', error);
                alert('Failed to relabel discovery');
            }
        }
        
        // Per-category actions for detected objects
        async function confirmSelectedInGroup(groupDetectionIds) {
            // Filter to only selected items within this group
            const selected = groupDetectionIds.filter(id => selectedObjects.has(id));
            if (selected.length === 0) {
                alert('Please select at least one object in this group');
                return;
            }
            if (!confirm(`Confirm ${selected.length} selected detection(s) as correct?\n\nThese will be moved to confirmed folder and removed from review list.`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/detected_objects/confirm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ detections: selected })
                });
                
                const data = await response.json();
                alert(data.message);
                
                // Clear selections and reload
                selected.forEach(id => selectedObjects.delete(id));
                loadDetectedObjects();
            } catch (error) {
                console.error('Failed to confirm objects:', error);
                alert('Failed to confirm some objects');
            }
        }
        
        async function deleteSelectedInGroup(groupDetectionIds) {
            // Filter to only selected items within this group
            const selected = groupDetectionIds.filter(id => selectedObjects.has(id));
            if (selected.length === 0) {
                alert('Please select at least one object in this group');
                return;
            }
            if (!confirm(`Delete ${selected.length} selected detection(s)?\n\nThese are incorrectly identified and will be removed.`)) {
                return;
            }
            
            try {
                // Parse label:filename format and group by label
                const byLabel = {};
                for (const detectionId of selected) {
                    const [label, filename] = detectionId.split(':');
                    if (!byLabel[label]) byLabel[label] = [];
                    byLabel[label].push(filename);
                }
                
                // Delete each
                let deleted = 0;
                for (const [label, filenames] of Object.entries(byLabel)) {
                    for (const filename of filenames) {
                        const response = await fetch('/api/detected_objects/relabel', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                old_label: label,
                                new_label: '',
                                filename: filename,
                                action: 'delete'
                            })
                        });
                        if (response.ok) deleted++;
                    }
                }
                
                alert(`Deleted ${deleted} detection(s)`);
                selected.forEach(id => selectedObjects.delete(id));
                loadDetectedObjects();
                
            } catch (error) {
                console.error('Failed to delete objects:', error);
                alert('Failed to delete some objects');
            }
        }
        
        async function confirmCategoryObjects(label, detectionIds) {
            if (!confirm(`Confirm all ${label} detections as correct?\n\nThese will be moved to confirmed folder and removed from review list.`)) return;
            
            try {
                const response = await fetch('/api/detected_objects/confirm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ detections: detectionIds })
                });
                
                const data = await response.json();
                alert(data.message);
                loadDetectedObjects();
            } catch (error) {
                console.error('Failed to confirm category:', error);
                alert('Failed to confirm some objects');
            }
        }
        
        async function deleteCategoryObjects(label, detectionIds) {
            if (!confirm(`Delete all ${label} detections?\n\nThese will be marked as incorrect.`)) return;
            
            try {
                let deleted = 0;
                for (const detectionId of detectionIds) {
                    const [lbl, filename] = detectionId.split(':');
                    const response = await fetch('/api/detected_objects/relabel', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            old_label: lbl,
                            new_label: '',
                            filename: filename,
                            action: 'delete'
                        })
                    });
                    if (response.ok) deleted++;
                }
                alert(`Deleted ${deleted} ${label} detection(s)`);
                loadDetectedObjects();
            } catch (error) {
                console.error('Failed to delete category:', error);
                alert('Failed to delete some detections');
            }
        }
        
        async function relabelCategoryObjects(label, detectionIds) {
            const newLabel = prompt(`Relabel all ${label} detections\n\nEnter the CORRECT label:`);
            if (newLabel === null || newLabel.trim() === '') return;
            
            const correctedLabel = newLabel.trim().toLowerCase();
            
            try {
                let relabeled = 0;
                for (const detectionId of detectionIds) {
                    const [lbl, filename] = detectionId.split(':');
                    const response = await fetch('/api/detected_objects/relabel', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            old_label: lbl,
                            new_label: correctedLabel,
                            filename: filename,
                            action: 'relabel'
                        })
                    });
                    if (response.ok) relabeled++;
                }
                alert(`Relabeled ${relabeled} ${label} detection(s) to "${correctedLabel}"`);
                loadDetectedObjects();
            } catch (error) {
                console.error('Failed to relabel category:', error);
                alert('Failed to relabel some detections');
            }
        }
        
        // ===== PHASE 2: ENHANCED REVIEW & LABEL FUNCTIONS =====
        
        // Toast Notifications
        function showToast(message, type = 'success') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span>${message}</span>
                <span class="toast-close" onclick="this.parentElement.remove()">&times;</span>
            `;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 5000);
        }
        
        // Replace alert() calls with toast for better UX
        function showProgress(message) {
            const overlay = document.createElement('div');
            overlay.id = 'progressOverlay';
            overlay.className = 'progress-overlay';
            overlay.innerHTML = `
                <div class="progress-content">
                    <div style="font-size: 1.25rem; margin-bottom: 1rem;">${message}</div>
                    <div class="progress-bar">
                        <div class="progress-bar-fill" id="progressBarFill" style="width: 0%;"></div>
                    </div>
                    <div id="progressText" style="color: var(--text-secondary); margin-top: 0.5rem;">0%</div>
                </div>
            `;
            document.body.appendChild(overlay);
        }
        
        function updateProgress(percent) {
            const fill = document.getElementById('progressBarFill');
            const text = document.getElementById('progressText');
            if (fill) fill.style.width = `${percent}%`;
            if (text) text.textContent = `${percent}%`;
        }
        
        function hideProgress() {
            const overlay = document.getElementById('progressOverlay');
            if (overlay) overlay.remove();
        }
        
        // Keyboard shortcuts for multi-select
        function toggleObjectSelection(detectionId, event) {
            if (event) event.stopPropagation();
            const saferId = detectionId.replace(/[^a-z0-9]/gi, '-');
            const element = document.getElementById(`object-${saferId}`);
            
            // Ctrl+A - Select all
            if (event && event.ctrlKey && event.key === 'a') {
                event.preventDefault();
                selectAllVisibleObjects();
                return;
            }
            
            // Shift+Click - Range selection
            if (event && event.shiftKey && lastSelectedObject) {
                selectRangeObjects(lastSelectedObject, detectionId);
                return;
            }
            
            // Ctrl+Click or regular click - Toggle individual
            if (selectedObjects.has(detectionId)) {
                selectedObjects.delete(detectionId);
                element.classList.remove('selected');
            } else {
                selectedObjects.add(detectionId);
                element.classList.add('selected');
                lastSelectedObject = detectionId;
            }
        }
        
        function selectAllVisibleObjects() {
            const items = document.querySelectorAll('.image-item[id^="object-"]');
            items.forEach(item => {
                const id = item.id.replace('object-', '').replace(/-/g, ':');
                selectedObjects.add(id);
                item.classList.add('selected');
            });
            showToast(`Selected ${items.length} objects`, 'success');
        }
        
        function selectRangeObjects(start, end) {
            const items = Array.from(document.querySelectorAll('.image-item[id^="object-"]'));
            const startIdx = items.findIndex(item => item.id.includes(start.replace(/:/g, '-')));
            const endIdx = items.findIndex(item => item.id.includes(end.replace(/:/g, '-')));
            
            if (startIdx >= 0 && endIdx >= 0) {
                const [from, to] = startIdx < endIdx ? [startIdx, endIdx] : [endIdx, startIdx];
                for (let i = from; i <= to; i++) {
                    const item = items[i];
                    const id = item.id.replace('object-', '').replace(/-/g, ':');
                    selectedObjects.add(id);
                    item.classList.add('selected');
                }
            }
        }
        
        // Global keyboard listener for Ctrl+A
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'a' && currentTab === 'review') {
                e.preventDefault();
                selectAllVisibleObjects();
            }
        });
        
        // Filter and Sort Functions
        function filterDiscoveries() {
            if (!discoveryData || discoveryData.length === 0) return;
            
            const searchTerm = document.getElementById('discoverySearchInput').value.toLowerCase();
            const minConf = parseFloat(document.getElementById('discoveryMinConfidence').value);
            const sortBy = document.getElementById('discoverySortBy').value;
            
            let filtered = discoveryData.filter(d => {
                const matchesSearch = d.label.toLowerCase().includes(searchTerm);
                const matchesConf = d.avg_confidence >= minConf;
                return matchesSearch && matchesConf;
            });
            
            // Sort
            filtered.sort((a, b) => {
                if (sortBy === 'label') return a.label.localeCompare(b.label);
                if (sortBy === 'confidence') return b.avg_confidence - a.avg_confidence;
                if (sortBy === 'date') return new Date(b.first_seen) - new Date(a.first_seen);
                return 0;
            });
            
            renderDiscoveries(filtered);
        }
        
        function resetDiscoveryFilters() {
            document.getElementById('discoverySearchInput').value = '';
            document.getElementById('discoveryMinConfidence').value = '0';
            document.getElementById('discoverySortBy').value = 'label';
            filterDiscoveries();
        }
        
        function filterDetectedObjects() {
            if (!detectedData || detectedData.length === 0) return;
            
            const searchTerm = document.getElementById('detectedSearchInput').value.toLowerCase();
            const minConf = parseFloat(document.getElementById('detectedMinConfidence').value);
            const sortBy = document.getElementById('detectedSortBy').value;
            
            let filtered = [];
            detectedData.forEach(obj => {
                const matchesSearch = obj.label.toLowerCase().includes(searchTerm);
                const avgConf = obj.detections.reduce((sum, d) => sum + d.confidence, 0) / obj.detections.length;
                const matchesConf = avgConf >= minConf;
                
                if (matchesSearch && matchesConf) {
                    filtered.push(obj);
                }
            });
            
            // Sort
            filtered.sort((a, b) => {
                if (sortBy === 'label') return a.label.localeCompare(b.label);
                if (sortBy === 'confidence') {
                    const avgA = a.detections.reduce((sum, d) => sum + d.confidence, 0) / a.detections.length;
                    const avgB = b.detections.reduce((sum, d) => sum + d.confidence, 0) / b.detections.length;
                    return avgB - avgA;
                }
                return 0;
            });
            
            renderDetectedObjects(filtered);
        }
        
        function resetDetectedFilters() {
            document.getElementById('detectedSearchInput').value = '';
            document.getElementById('detectedMinConfidence').value = '0';
            document.getElementById('detectedSortBy').value = 'label';
            filterDetectedObjects();
        }
        
        function renderDiscoveries(data) {
            const container = document.getElementById('discoveriesContainer');
            let html = '';
            
            for (const discovery of data) {
                const avgConfidence = (discovery.avg_confidence * 100).toFixed(1);
                html += `
                    <div class="group-header">
                        <div>
                            <strong>${discovery.label}</strong> - ${discovery.detection_count} detection(s), ${avgConfidence}% confidence
                            <div style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.25rem;">
                                First seen: ${new Date(discovery.first_seen).toLocaleDateString()}
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <input type="checkbox" id="discovery-${discovery.label}" onchange="toggleDiscovery('${discovery.label}')" style="width: auto; margin-right: 0.5rem;">
                            <label for="discovery-${discovery.label}">Select</label>
                        </div>
                    </div>
                    <div class="image-grid">
                `;
                
                for (const img of discovery.sample_images) {
                    const imageSrc = `/api/detected_objects/image/${img.path}`;
                    const detectionId = `${discovery.label}:${img.filename}`;
                    html += `
                        <div class="image-item" 
                             ondblclick="openZoomModalDiscovery('${imageSrc}', '${discovery.label}', ${discovery.avg_confidence}, '${detectionId}')"
                             title="Double-click to zoom">
                            <img data-src="${imageSrc}" alt="${discovery.label}" class="lazy">
                            <div class="confidence-badge">${discovery.label}</div>
                        </div>
                    `;
                }
                
                html += `
                    </div>
                    <div class="label-controls" style="margin-top: 0.75rem; margin-bottom: 1rem; padding-top: 0.75rem; border-top: 1px solid var(--border-color);">
                        <button class="btn btn-small" onclick="trackSingleDiscovery('${discovery.label}')" style="background: var(--success-color);" title="Add '${discovery.label}' to Species Training page and enable tracking">‚úì Enable</button>
                        <button class="btn btn-small" onclick="blacklistSingleDiscovery('${discovery.label}')" style="background: var(--warning-color); color: white;" title="Stop Discovery Mode from suggesting '${discovery.label}' (adds to blacklist)">‚úó Blacklist</button>
                        <button class="btn btn-small" onclick="relabelSingleDiscovery('${discovery.label}')" style="background: var(--danger-color);" title="Correct wrong identification - moves images to correct folder (does not retrain YOLO)">üè∑ Relabel</button>
                    </div>
                `;
            }
            
            html += `
                <div class="label-controls" style="margin-top: 1.5rem;">
                    <button class="btn" onclick="approveDiscoveries()" style="background: var(--success-color);" title="Add selected objects to Species Training page and enable tracking">‚úì Enable Selected</button>
                    <button class="btn" onclick="ignoreDiscoveries()" style="background: var(--warning-color); color: white;" title="Stop Discovery Mode from suggesting these objects (adds to blacklist)">‚úó Blacklist Selected</button>
                    <button class="btn" onclick="relabelDiscoveries()" style="background: var(--danger-color);" title="Correct wrong identification - moves images to correct folder (does not retrain YOLO)">‚ùå Relabel Selected</button>
                </div>
            `;
            
            container.innerHTML = html;
            lazyLoadImages();
        }
        
        function renderDetectedObjects(data) {
            const container = document.getElementById('detectedObjectsContainer');
            let html = '';
            
            for (const obj of data) {
                const groupId = `obj-${obj.label.replace(/[^a-z0-9]/gi, '-')}`;
                const detectionFilenames = obj.detections.map(d => `${obj.label}:${d.filename}`);
                
                html += `
                    <div class="group-header">
                        <div>
                            <strong>${obj.label}</strong> - ${obj.count} detection(s)
                        </div>
                        <button class="btn btn-small" onclick="selectAllObjects('${groupId}', ${JSON.stringify(detectionFilenames).replace(/"/g, '&quot;')})" title="Select all ${obj.label} detections">Select All</button>
                    </div>
                    <div class="image-grid">
                `;
                
                for (const detection of obj.detections) {
                    const confidence = (detection.confidence * 100).toFixed(1);
                    const confidenceValue = detection.confidence;
                    const detectionId = `${obj.label}:${detection.filename}`;
                    const imageSrc = `/api/detected_objects/image/${detection.path}`;
                    html += `
                        <div class="image-item" 
                             id="object-${detectionId.replace(/[^a-z0-9]/gi, '-')}" 
                             onclick="toggleObjectSelection('${detectionId}', event)"
                             ondblclick="openZoomModal('${imageSrc}', '${obj.label}', ${confidenceValue}, '${detectionId}'); event.stopPropagation();"
                             title="Click to select | Double-click to zoom">
                            <img data-src="${imageSrc}" alt="${obj.label}" class="lazy">
                            <div class="confidence-badge">${confidence}% ${obj.label}</div>
                        </div>
                    `;
                }
                
                html += `
                    </div>
                    <div class="label-controls" style="margin-top: 0.75rem; margin-bottom: 1rem; padding-top: 0.75rem; border-top: 1px solid var(--border-color);">
                        <button class="btn btn-small" onclick="confirmSelectedInGroup(${JSON.stringify(detectionFilenames).replace(/"/g, '&quot;')})" style="background: var(--success-color);" title="Confirm selected ${obj.label} detections as correct">‚úì Confirm Selected</button>
                        <button class="btn btn-small" onclick="deleteSelectedInGroup(${JSON.stringify(detectionFilenames).replace(/"/g, '&quot;')})" style="background: var(--danger-color);" title="Delete selected ${obj.label} detections">‚úó Delete Selected</button>
                        <button class="btn btn-small" onclick="confirmCategoryObjects('${obj.label}', ${JSON.stringify(detectionFilenames).replace(/"/g, '&quot;')})" style="background: var(--success-color);" title="Confirm all ${obj.label} detections as correct">‚úì Confirm All</button>
                        <button class="btn btn-small" onclick="deleteCategoryObjects('${obj.label}', ${JSON.stringify(detectionFilenames).replace(/"/g, '&quot;')})" style="background: var(--danger-color);" title="Delete all ${obj.label} detections">‚úó Delete All</button>
                        <button class="btn btn-small" onclick="relabelCategoryObjects('${obj.label}', ${JSON.stringify(detectionFilenames).replace(/"/g, '&quot;')})" style="background: var(--warning-color); color: white;" title="Relabel all ${obj.label} detections">üè∑ Relabel All</button>
                    </div>
                `;
            }
            
            html += `
                <div class="label-controls" style="margin-top: 1.5rem;">
                    <button class="btn" onclick="confirmSelectedObjects()" style="background: var(--success-color);">‚úì Confirm Selected as Correct</button>
                    <button class="btn" onclick="deleteSelectedObjects()" style="background: var(--danger-color);">‚úó Delete Selected (Incorrect)</button>
                    <button class="btn" onclick="relabelSelectedObjects()" style="background: var(--warning-color); color: white;">üè∑Ô∏è Relabel Selected</button>
                </div>
            `;
            
            container.innerHTML = html;
            lazyLoadImages();
        }
        
        // Lazy loading for images
        function lazyLoadImages() {
            const lazyImages = document.querySelectorAll('img.lazy[data-src]');
            
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        img.src = img.dataset.src;
                        img.classList.add('loaded');
                        img.classList.remove('lazy');
                        observer.unobserve(img);
                    }
                });
            });
            
            lazyImages.forEach(img => imageObserver.observe(img));
        }
        
        // Enhanced zoom modal with keyboard navigation - handled by earlier definition
        
        // ===== END PHASE 2 =====
        
        // ===== PHASE 3: Analytics, Metrics, Export, Training Management =====
        
        let analyticsChart = null;
        let timelineChart = null;
        let storageChart = null;
        
        // Load Analytics
        async function loadAnalytics() {
            try {
                const response = await fetch('/api/analytics/stats');
                const data = await response.json();
                
                // Update stat cards
                document.getElementById('analyticsVideos').textContent = data.total_videos;
                document.getElementById('analyticsDetections').textContent = data.total_detections;
                document.getElementById('analyticsCategories').textContent = Object.keys(data.categories).length;
                document.getElementById('analyticsTrainedFaces').textContent = Object.keys(data.face_recognition_stats).length;
                
                // Render analytics chart
                renderAnalyticsChart(data.categories);
                
                // Render top detections
                renderTopDetections(data.top_detections);
                
                // Render face recognition stats
                renderFaceRecognitionStats(data.face_recognition_stats);
                
                // Load timeline
                loadTimeline();
            } catch (error) {
                console.error('Failed to load analytics:', error);
            }
        }
        
        async function loadTimeline() {
            try {
                const response = await fetch('/api/analytics/timeline?days=30');
                const data = await response.json();
                renderTimelineChart(data.timeline);
            } catch (error) {
                console.error('Failed to load timeline:', error);
            }
        }
        
        function renderAnalyticsChart(categories) {
            const ctx = document.getElementById('analyticsChart');
            if (!ctx) return;
            
            const labels = Object.keys(categories);
            const values = Object.values(categories);
            
            if (analyticsChart) {
                analyticsChart.destroy();
            }
            
            analyticsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Videos',
                        data: values,
                        backgroundColor: 'rgba(66, 153, 225, 0.5)',
                        borderColor: 'rgba(66, 153, 225, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function renderTimelineChart(timeline) {
            const ctx = document.getElementById('timelineChart');
            if (!ctx) return;
            
            const labels = timeline.map(d => d.date);
            const values = timeline.map(d => d.videos);
            
            if (timelineChart) {
                timelineChart.destroy();
            }
            
            timelineChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Videos Processed',
                        data: values,
                        borderColor: 'rgba(72, 187, 120, 1)',
                        backgroundColor: 'rgba(72, 187, 120, 0.2)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function renderTopDetections(topDetections) {
            const container = document.getElementById('topDetections');
            if (!container) return;
            
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr><th style="text-align: left; padding: 0.5rem; border-bottom: 2px solid var(--border-color);">Label</th>';
            html += '<th style="text-align: right; padding: 0.5rem; border-bottom: 2px solid var(--border-color);">Count</th></tr></thead>';
            html += '<tbody>';
            
            topDetections.forEach((item, index) => {
                html += `<tr style="${index % 2 === 0 ? 'background: var(--bg-secondary);' : ''}">`;
                html += `<td style="padding: 0.5rem;">${item.label}</td>`;
                html += `<td style="text-align: right; padding: 0.5rem; font-weight: bold; color: var(--accent-color);">${item.count}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        function renderFaceRecognitionStats(stats) {
            const container = document.getElementById('faceRecognitionStats');
            if (!container) return;
            
            if (Object.keys(stats).length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">No trained faces yet</p>';
                return;
            }
            
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr><th style="text-align: left; padding: 0.5rem; border-bottom: 2px solid var(--border-color);">Person</th>';
            html += '<th style="text-align: right; padding: 0.5rem; border-bottom: 2px solid var(--border-color);">Training Images</th>';
            html += '<th style="text-align: right; padding: 0.5rem; border-bottom: 2px solid var(--border-color);">Videos</th></tr></thead>';
            html += '<tbody>';
            
            Object.entries(stats).forEach(([person, data], index) => {
                html += `<tr style="${index % 2 === 0 ? 'background: var(--bg-secondary);' : ''}">`;
                html += `<td style="padding: 0.5rem;">${person}</td>`;
                html += `<td style="text-align: right; padding: 0.5rem;">${data.training_images}</td>`;
                html += `<td style="text-align: right; padding: 0.5rem; font-weight: bold; color: var(--accent-color);">${data.videos}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        // Load Metrics
        async function loadMetrics() {
            try {
                const response = await fetch('/api/metrics');
                const data = await response.json();
                
                // Update stat cards
                document.getElementById('metricsCPU').textContent = data.system.cpu_percent.toFixed(1) + '%';
                document.getElementById('metricsMemory').textContent = data.system.memory_percent.toFixed(1) + '%';
                document.getElementById('metricsDisk').textContent = data.system.disk_percent.toFixed(1) + '%';
                document.getElementById('metricsProcessing').textContent = data.processing.is_active ? 'Active' : 'Idle';
                
                // Render storage chart
                renderStorageChart(data.storage);
                
                // Render system metrics details
                renderSystemMetricsDetails(data);
            } catch (error) {
                console.error('Failed to load metrics:', error);
            }
        }
        
        function renderStorageChart(storage) {
            const ctx = document.getElementById('storageChart');
            if (!ctx) return;
            
            const labels = ['Downloads', 'Sorted', 'Faces', 'Objects'];
            const values = [storage.downloads, storage.sorted, storage.faces, storage.objects];
            
            if (storageChart) {
                storageChart.destroy();
            }
            
            storageChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: [
                            'rgba(66, 153, 225, 0.7)',
                            'rgba(72, 187, 120, 0.7)',
                            'rgba(237, 137, 54, 0.7)',
                            'rgba(245, 101, 101, 0.7)'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + context.parsed + ' MB';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderSystemMetricsDetails(data) {
            const container = document.getElementById('systemMetricsDetails');
            if (!container) return;
            
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">';
            
            html += `
                <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">
                    <div style="font-size: 0.875rem; color: var(--text-secondary);">Videos Processed</div>
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--accent-color); margin-top: 0.5rem;">
                        ${data.processing.videos_processed} / ${data.processing.videos_total}
                    </div>
                </div>
                <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">
                    <div style="font-size: 0.875rem; color: var(--text-secondary);">Storage Total</div>
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--accent-color); margin-top: 0.5rem;">
                        ${(data.storage.downloads + data.storage.sorted + data.storage.faces + data.storage.objects)} MB
                    </div>
                </div>
                <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">
                    <div style="font-size: 0.875rem; color: var(--text-secondary);">Last Run</div>
                    <div style="font-size: 1rem; font-weight: bold; margin-top: 0.5rem;">
                        ${data.processing.last_run || 'Never'}
                    </div>
                </div>
            `;
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        // Export Data
        async function exportData(type, format) {
            try {
                const response = await fetch(`/api/export/${type}?format=${format}`);
                
                if (format === 'csv') {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${type}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    showToast('Export successful!', 'success');
                } else {
                    const data = await response.json();
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${type}.json`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    showToast('Export successful!', 'success');
                }
            } catch (error) {
                console.error('Export failed:', error);
                showToast('Export failed', 'error');
            }
        }
        
        // Enhanced Face Training Management
        async function loadFaces() {
            const response = await fetch('/api/faces');
            const faces = await response.json();
            const list = document.getElementById('faceList');
            
            if (faces.length === 0) {
                list.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 2rem;">No trained faces yet. Upload training photos below.</p>';
                return;
            }
            
            let html = '';
            faces.forEach(face => {
                html += `
                    <div class="face-item">
                        <div>
                            <div class="face-name">${face.name}</div>
                            <div class="face-count">${face.image_count} training image(s)</div>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="retrainPerson('${face.name}')" style="background: var(--accent-color);">üîÑ Retrain</button>
                            <button class="btn btn-small" onclick="deletePerson('${face.name}')" style="background: var(--danger-color);">üóëÔ∏è Delete</button>
                        </div>
                    </div>
                `;
            });
            
            list.innerHTML = html;
        }
        
        async function retrainPerson(name) {
            if (!confirm(`Retrain face recognition for ${name}?`)) return;
            
            try {
                const response = await fetch(`/api/faces/train?person_name=${encodeURIComponent(name)}`, {
                    method: 'POST'
                });
                const data = await response.json();
                showToast(data.message || 'Retraining started', 'success');
            } catch (error) {
                showToast('Failed to start retraining', 'error');
            }
        }
        
        async function retrainAllFaces() {
            if (!confirm('Retrain all face recognition models? This may take a few minutes.')) return;
            
            try {
                const response = await fetch('/api/faces/retrain_all', {
                    method: 'POST'
                });
                const data = await response.json();
                showToast(data.message || 'Retraining started for all faces', 'success');
            } catch (error) {
                showToast('Failed to start retraining', 'error');
            }
        }
        
        async function deletePerson(name) {
            if (!confirm(`Delete all training data for ${name}? This cannot be undone.`)) return;
            
            try {
                const response = await fetch(`/api/faces/${encodeURIComponent(name)}`, {
                    method: 'DELETE'
                });
                const data = await response.json();
                showToast(data.message || `Deleted ${name}`, 'success');
                loadFaces();
            } catch (error) {
                showToast('Failed to delete person', 'error');
            }
        }
        
        async function loadAnalytics() {
            try {
                const response = await fetch('/api/analytics/stats');
                const stats = await response.json();
                
                // Update stat cards
                document.getElementById('analyticsVideos').textContent = stats.total_videos || 0;
                document.getElementById('analyticsDetections').textContent = stats.total_detections || 0;
                document.getElementById('analyticsStage2').textContent = stats.stage2_classifications || 0;
                
                // Count trained faces
                const trainedFaces = Object.keys(stats.face_recognition_stats || {}).length;
                document.getElementById('analyticsTrainedFaces').textContent = trainedFaces;
                
                // Display Stage 2 specialized detection stats
                const stage2Container = document.getElementById('stage2Stats');
                if (stats.specialized_stats && stats.specialized_stats.total > 0) {
                    let html = '<div class="face-list">';
                    
                    // Sort by count descending
                    const sortedSpecies = Object.entries(stats.specialized_stats.by_species)
                        .sort((a, b) => b[1] - a[1]);
                    
                    sortedSpecies.forEach(([species, count]) => {
                        html += `
                            <div class="face-item">
                                <div>
                                    <div class="face-name">ü¶î ${species}</div>
                                    <div class="face-count">Specialized classification</div>
                                </div>
                                <div class="stat-value" style="font-size: 1.5rem; margin: 0;">${count}</div>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                    html += `<p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.875rem;">
                        <strong>Stage 2 Detection:</strong> Videos analyzed with trained species-specific models to identify exact species beyond basic YOLO categories.
                    </p>`;
                    
                    stage2Container.innerHTML = html;
                } else {
                    stage2Container.innerHTML = `
                        <p style="color: var(--text-secondary);">
                            No Stage 2 classifications yet. Enable Specialized Detection in Configuration and train species models in Species Training.
                        </p>
                    `;
                }
                
            } catch (error) {
                console.error('Failed to load analytics:', error);
                document.getElementById('stage2Stats').innerHTML = 
                    '<p style="color: var(--danger-color);">Failed to load specialized detection stats</p>';
            }
        }
        
        // Update tab switching to include new tabs
        const originalSwitchTab = switchTab;
        switchTab = function(tabName) {
            originalSwitchTab(tabName);
            
            if (tabName === 'analytics') loadAnalytics();
            if (tabName === 'metrics') loadMetrics();
        };
        
        // ===== END PHASE 3 =====
        
        
        function startLogStream() {
            const logViewer = document.getElementById('logViewer');
            const eventSource = new EventSource('/api/logs/stream');
            
            eventSource.onmessage = (event) => {
                const logLine = document.createElement('div');
                logLine.className = 'log-line';
                logLine.textContent = event.data;
                
                if (event.data.includes('ERROR')) logLine.classList.add('error');
                else if (event.data.includes('WARNING')) logLine.classList.add('warning');
                else if (event.data.includes('INFO')) logLine.classList.add('info');
                
                logViewer.appendChild(logLine);
                logViewer.scrollTop = logViewer.scrollHeight;
            };
        }

        // Drag and drop - initialize after DOM loads
        function initUploadArea() {
            const uploadArea = document.getElementById('uploadArea');
            if (uploadArea) {
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    document.getElementById('fileInput').files = e.dataTransfer.files;
                    uploadFiles();
                });
            }
        }

        // Update checker
        function checkForUpdates() {
            const lastCheck = localStorage.getItem('lastUpdateCheck');
            const now = Date.now();
            const checkInterval = 6 * 60 * 60 * 1000; // 6 hours
            
            if (lastCheck && (now - parseInt(lastCheck)) < checkInterval) {
                // Use cached result
                const cachedResult = localStorage.getItem('updateCheckResult');
                if (cachedResult) {
                    const result = JSON.parse(cachedResult);
                    if (result.update_available) {
                        showUpdateBanner(result);
                    }
                }
                return;
            }
            
            // Perform new check
            fetch('/api/check_update')
                .then(r => r.json())
                .then(data => {
                    if (data.success && data.update_available) {
                        showUpdateBanner(data);
                    }
                    // Cache the result
                    localStorage.setItem('lastUpdateCheck', now.toString());
                    localStorage.setItem('updateCheckResult', JSON.stringify(data));
                })
                .catch(err => {
                    console.log('Update check failed:', err);
                });
        }
        
        function showUpdateBanner(data) {
            const banner = document.getElementById('update-banner');
            const versionSpan = document.getElementById('update-version');
            const link = document.getElementById('update-link');
            
            if (banner && versionSpan && link) {
                versionSpan.textContent = `${data.latest_version} is now available`;
                link.href = data.release_url;
                banner.classList.add('show');
            }
        }

        // Check Discovery Mode status and dim tab if needed
        async function checkDiscoveryModeStatus() {
            try {
                const response = await fetch('/api/config');
                const data = await response.json();
                const discoveryMode = data.config?.detection?.discovery_mode !== undefined ? data.config.detection.discovery_mode : true;
                
                const discoveryTab = document.getElementById('discoveryTab');
                if (discoveryMode) {
                    discoveryTab.classList.remove('disabled');
                } else {
                    discoveryTab.classList.add('disabled');
                }
            } catch (error) {
                console.error('Failed to check discovery mode status:', error);
            }
        }
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Set theme toggle button text
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) {
                themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            }
            
            // Initialize drag and drop
            initUploadArea();
            
            // Check Ring auth status
            checkRingAuthStatus();
            
            // Check and dim Discovery Mode tab if needed
            checkDiscoveryModeStatus();
            
            // Start fetching status
            fetchStatus();
            fetchStats();
            checkForUpdates();
            
            // Auto-refresh with configurable rate
            refreshInterval = setInterval(() => {
                fetchStatus();
                fetchStats();
                if (currentTab === 'videos') {
                    loadVideos();
                }
            }, currentRefreshRate);
        });
    </script>
</body>
</html>
